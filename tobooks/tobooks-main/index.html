<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>EPUB é˜…è¯»å™¨</title>
    
    <link rel="icon" href="public/image.png" type="image/png">
    <link rel="shortcut icon" href="public/image.png" type="image/png">
    <!-- Open Graph for Netlify/social preview -->
    <meta property="og:title" content="tobooks" />
    <meta property="og:description" content="Your EPUB reader project" />
    <meta property="og:image" content="https://tobooks.netlify.app/resized_QQ_1752659402232.png" />
    <meta property="og:image:width" content="1200" />
    <meta property="og:image:height" content="630" />
    <meta property="og:type" content="website" />
    <!-- Twitter Card -->
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content="tobooks" />
    <meta name="twitter:description" content="Your EPUB reader project" />
    <meta name="twitter:image" content="https://tobooks.netlify.app/resized_QQ_1752659402232.png" />
    <script src="lib/jszip.js"></script>
    <script src="lib/localforage.js"></script>
    <script src="lib/epub.js"></script>
    <!-- å•æ¬¡ç¿»é¡µ + æ·¡å…¥æ·¡å‡ºæ•ˆæœ -->
    <script src="page-turn.js"></script>
    <script src="highlight-manager.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #f7f7f7;
            font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Text', 'SF Pro Icons', sans-serif;
            overflow: hidden;
            height: 100vh;
            min-height: 100dvh;
            /* iOS å®‰å…¨åŒºåŸŸ */
            padding-top: env(safe-area-inset-top);
            padding-top: constant(safe-area-inset-top);
            padding-bottom: env(safe-area-inset-bottom);
            padding-bottom: constant(safe-area-inset-bottom);
            width: 100vw;
            display: flex;
            flex-direction: column;
        }

        #main-container {
            flex: 1;
            display: flex;
            position: relative;
            /* é¿å…åº•éƒ¨ Home æŒ‡ç¤ºæ¡é®æŒ¡ */
            padding-bottom: env(safe-area-inset-bottom);
            padding-bottom: constant(safe-area-inset-bottom);
        }

        #viewer {
            flex: 1;
            height: 100%;
            background: white;
            position: relative;
            overflow: hidden;
        }

        /* å·¦å³ç®­å¤´æŒ‰é’®ï¼ˆå¯ç‚¹å‡»ï¼Œé¢ç§¯å°ï¼Œä¸å¹²æ‰°æ‰‹åŠ¿ï¼‰ */
        .arrow-button {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            width: 44px;
            height: 44px;
            border: none;
            border-radius: 22px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            background: rgba(0,0,0,0.04);
            color: #666;
            z-index: 1000;
            transition: background 160ms ease, transform 160ms ease, opacity 160ms ease;
            opacity: 0;
            pointer-events: none;
        }
        .arrow-button svg { width: 20px; height: 20px; pointer-events: none; }
        .arrow-button.left { left: 12px; }
        .arrow-button.right { right: 12px; }
        .arrow-button:hover { background: rgba(0,0,0,0.08); }
        .arrow-button:active { transform: translateY(-50%) scale(0.98); }
        /* å½“æ¥è¿‘å¯¹åº”è¾¹ç¼˜æ—¶æ˜¾ç¤º */
        #viewer.show-left .arrow-button.left { opacity: 1; pointer-events: auto; }
        #viewer.show-right .arrow-button.right { opacity: 1; pointer-events: auto; }
        @media (prefers-color-scheme: dark) {
            .arrow-button { background: rgba(255,255,255,0.06); color:#bbb; }
            .arrow-button:hover { background: rgba(255,255,255,0.12); }
        }

        /* é¡¶éƒ¨æ è‡ªåŠ¨éšè—/æ˜¾ç¤º */
        #top-bar.auto-hide { transform: translateY(-100%); opacity: 0; pointer-events: none; transition: transform 180ms ease, opacity 180ms ease; }
        #top-bar.auto-hide.show { transform: translateY(0); opacity: 1; pointer-events: auto; }

        /* æ‹–æ‹½ä¸Šä¼ åŒºåŸŸæ ·å¼ */
        .upload-area {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            background: white;
            z-index: 10;
        }

        .upload-content {
            text-align: center;
            padding: 40px;
            border: 2px dashed #e0e0e0;
            border-radius: 12px;
            background: #fafafa;
            transition: all 0.3s ease;
            cursor: pointer;
            max-width: 400px;
            width: 100%;
        }

        .upload-content:hover {
            border-color: #1976d2;
            background: #f0f8ff;
        }

        .upload-content.dragover {
            border-color: #1976d2;
            background: #e3f2fd;
            transform: scale(1.02);
        }

        .upload-icon {
            width: 80px;
            height: 80px;
            margin-bottom: 20px;
            opacity: 0.7;
        }

        .upload-title {
            font-size: 18px;
            font-weight: 600;
            color: #333;
            margin-bottom: 15px;
            line-height: 1.4;
        }

        .upload-subtitle {
            font-size: 16px;
            font-weight: 500;
            color: #1976d2;
            margin-bottom: 10px;
            text-decoration: underline;
            cursor: pointer;
        }

        .upload-subtitle:hover {
            color: #1565c0;
        }

        .upload-formats {
            font-size: 14px;
            color: #666;
            margin: 0;
        }

        /* éšè—ä¸Šä¼ åŒºåŸŸå½“æœ‰ä¹¦æ—¶ */
        .upload-area.hidden {
            display: none;
        }

        .nav-button {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 40px;
            background: transparent;
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            z-index: 100;
        }

        .nav-button:hover {
            background: rgba(0, 0, 0, 0.03);
        }
        
        .nav-button:active {
            background: rgba(0, 0, 0, 0.08);
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.2);
            transform: translateY(1px);
        }

        #prev-button {
            left: 0;
        }

        #next-button {
            right: 0;
        }

        .nav-button svg {
            width: 20px;
            height: 20px;
            fill: #666;
        }

        /* åœ¨ç§»åŠ¨è®¾å¤‡ä¸Šæ‰©å¤§ç‚¹å‡»åŒºåŸŸ */
        @media (max-width: 768px) {
            .nav-button {
                width: 60px;
            }
        }

        #top-bar {
            min-height: 48px;
            height: auto;
            background: white;
            backdrop-filter: blur(10px);
            border-bottom: 1px solid rgba(0, 0, 0, 0.1);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 10px 20px;
            position: relative;
            z-index: 100;
            gap: 16px;
            /* iOS é¡¶éƒ¨å®‰å…¨åŒº */
            padding-top: max(10px, env(safe-area-inset-top));
        }

        #top-bar-left {
            display: flex;
            align-items: center;
            gap: 8px;
            flex-shrink: 0;
        }

        #top-bar-center {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            min-width: 0;
            max-width: 280px;
        }

        #top-bar-right {
            display: flex;
            align-items: center;
            gap: 8px;
            flex-shrink: 0;
        }
        
        #file-input-container {
            cursor: pointer;
        }

        .top-button,
        .theme-button {
            padding: 10px 14px;
            border: none;
            background: var(--theme-button-bg, #f5f5f5);
            color: var(--theme-button-color, #333);
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            border-radius: 8px;
            display: flex;
            align-items: center;
            gap: 6px;
            transition: all 0.15s ease;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.08);
            white-space: nowrap;
        }
        
        /* çª„å±æ—¶éšè—æŒ‰é’®æ–‡å­—ï¼Œåªæ˜¾ç¤ºå›¾æ ‡ */
        @media (max-width: 800px) {
            .top-button > span,
            .theme-button > span {
                display: none;
            }
            .top-button,
            .theme-button {
                padding: 10px 12px;
            }
        }

        .top-button:hover,
        .theme-button:hover {
            background: #e8e8e8;
            transform: translateY(-1px);
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.12);
        }

        .top-button:active,
        .top-button.active,
        .theme-button:active {
            background: #ddd;
            transform: translateY(0);
            box-shadow: inset 0 1px 2px rgba(0,0,0,0.1);
        }

        .epub-container {
            width: 100%;
            height: 100%;
            overflow: hidden;
            position: relative;
        }

        /* æœç´¢ç›¸å…³æ ·å¼ */
        .search-container {
            display: flex;
            align-items: center;
            gap: 6px;
            position: relative;
            background: rgba(0, 0, 0, 0.05);
            border-radius: 8px;
            padding: 6px 10px;
            transition: all 0.2s;
            width: 100%;
            min-width: 80px;
        }

        .search-container:hover {
            background: rgba(0, 0, 0, 0.08);
        }

        .search-container:focus-within {
            background: white;
            box-shadow: 0 0 0 2px rgba(25, 118, 210, 0.1);
        }

        .search-icon {
            fill: #666;
            flex-shrink: 0;
        }

        #search-input {
            border: none;
            background: transparent;
            font-size: 14px;
            flex: 1;
            color: #333;
            outline: none;
            font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Text', sans-serif;
        }

        #search-input::placeholder {
            color: #999;
        }

        #search-info {
            font-size: 12px;
            color: #666;
            padding: 2px 6px;
            background: rgba(25, 118, 210, 0.1);
            border-radius: 3px;
            min-width: 30px;
            text-align: center;
            white-space: nowrap;
            opacity: 0;
            transition: opacity 0.2s;
        }

        .search-container:focus-within #search-info {
            opacity: 1;
        }

        #search-info:empty {
            opacity: 0;
        }

        @media (max-width: 720px) {
            #top-bar {
                flex-wrap: wrap;
                height: auto;
                gap: 8px;
                align-items: flex-start;
                padding-left: 12px;
                padding-right: 12px;
                padding-bottom: 8px;
            }

            #top-bar-left,
            #top-bar-right {
                flex: 1 1 0;
                flex-wrap: wrap;
                gap: 6px;
            }

            #top-bar-center {
                order: 3;
                width: 100%;
            }

            .search-container {
                max-width: none;
            }

            .top-button,
            .theme-button {
                padding: 6px 10px;
                font-size: 13px;
            }
        }

        /* æœç´¢é«˜äº®æ ·å¼ */
        .search-highlight {
            background-color: yellow !important;
            color: black !important;
        }

        .epubjs-hl.search-highlight {
            background-color: yellow !important;
            color: black !important;
        }

        /* ä¸»é¢˜åˆ‡æ¢å™¨æ ·å¼ */
        .theme-switcher {
            position: relative;
            display: inline-block;
            z-index: 9998;
        }

        .theme-button {
            padding: 8px 16px;
            border: none;
            background: var(--theme-button-bg, #1976d2);
            color: var(--theme-button-color, white);
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            border-radius: 6px;
            display: flex;
            align-items: center;
            gap: 6px;
            transition: all 0.2s;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .theme-button:hover {
            opacity: 0.9;
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }
        
        .theme-button:active,
        .theme-button.active {
            background: var(--theme-button-bg, #1976d2);
            color: black;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.3), inset 0 1px 2px rgba(0,0,0,0.2);
            transform: translateY(1px);
        }

        /* è®©é¡¶éƒ¨æŒ‰é’®çš„å‡¹é™·æ•ˆæœä¸ä¸»é¢˜æŒ‰é’®ä¸€è‡´ */
        .top-button:active,
        .top-button.active {
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.3), inset 0 1px 2px rgba(0,0,0,0.2);
            transform: translateY(1px);
        }
        
        .theme-button:active svg,
        .theme-button.active svg {
            fill: black;
        }

        .theme-dropdown {
            position: absolute;
            top: 100%;
            left: 0;
            background: white;
            border: 2px solid #1976d2;
            border-radius: 8px;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.25);
            z-index: 9999;
            min-width: 200px;
            padding: 8px 0;
            display: none;
            max-height: 300px;
            overflow-y: auto;
        }

        .theme-dropdown.show {
            display: block !important;
            visibility: visible !important;
            opacity: 1 !important;
        }

        .theme-option {
            display: flex;
            align-items: center;
            padding: 10px 16px;
            cursor: pointer;
            transition: all 0.2s;
            border: none;
            background: none;
            width: 100%;
            text-align: left;
        }

        .theme-option:hover {
            background: #f0f0f0;
            transform: translateX(2px);
        }

        .theme-option.active {
            background: #e3f2fd;
            color: #1976d2;
        }

        .theme-preview {
            width: 24px;
            height: 24px;
            border-radius: 6px;
            margin-right: 12px;
            border: 2px solid #e0e0e0;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);
        }

        .theme-name {
            font-size: 14px;
            font-weight: 500;
        }

        /* ä¸»é¢˜æ ·å¼å®šä¹‰ */
        [data-theme="default"] {
            --bg-color: #f7f7f7;
            --text-color: #333;
            --reader-bg: white;
            --topbar-bg: white;
            --border-color: rgba(0, 0, 0, 0.1);
            --button-hover: rgba(0, 0, 0, 0.05);
            --theme-button-bg: white;
            --theme-button-color: #333;
        }

        [data-theme="ink"] {
            --bg-color: #f5f3f0;
            --text-color: #2c2c2c;
            --reader-bg: #fefefe;
            --topbar-bg: white;
            --border-color: rgba(44, 44, 44, 0.1);
            --button-hover: rgba(44, 44, 44, 0.05);
            --theme-button-bg: #2c2c2c;
            --theme-button-color: white;
        }

        [data-theme="blue"] {
            --bg-color: #f0f4f8;
            --text-color: #1a365d;
            --reader-bg: #ffffff;
            --topbar-bg: white;
            --border-color: rgba(26, 54, 93, 0.1);
            --button-hover: rgba(26, 54, 93, 0.05);
            --theme-button-bg: #1a365d;
            --theme-button-color: white;
        }

        [data-theme="purple"] {
            --bg-color: #f8f4ff;
            --text-color: #553c9a;
            --reader-bg: #ffffff;
            --topbar-bg: white;
            --border-color: rgba(85, 60, 154, 0.1);
            --button-hover: rgba(85, 60, 154, 0.05);
            --theme-button-bg: #553c9a;
            --theme-button-color: white;
        }

        [data-theme="green"] {
            --bg-color: #f0fdf4;
            --text-color: #166534;
            --reader-bg: #ffffff;
            --topbar-bg: white;
            --border-color: rgba(22, 101, 52, 0.1);
            --button-hover: rgba(22, 101, 52, 0.05);
            --theme-button-bg: #166534;
            --theme-button-color: white;
        }

        [data-theme="warm"] {
            --bg-color: #fef7ed;
            --text-color: #9a3412;
            --reader-bg: #ffffff;
            --topbar-bg: white;
            --border-color: rgba(154, 52, 18, 0.1);
            --button-hover: rgba(154, 52, 18, 0.05);
            --theme-button-bg: #9a3412;
            --theme-button-color: white;
        }


        /* åº”ç”¨ä¸»é¢˜å˜é‡ */
        body {
            background: var(--bg-color);
            color: var(--text-color);
        }

        #viewer {
            background: var(--reader-bg);
        }

        #top-bar {
            background: var(--topbar-bg);
            border-bottom: 1px solid var(--border-color);
        }

        .top-button:hover {
            background: var(--button-hover);
        }

        .nav-button:hover {
            background: var(--button-hover);
        }
        
        .nav-button:active {
            background: var(--button-hover);
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.2);
            transform: translateY(1px);
        }

        .search-container {
            background: var(--button-hover);
        }

        .search-container:hover {
            background: var(--button-hover);
        }

        .search-container:focus-within {
            background: var(--reader-bg);
        }

        /* ç¬”è®°é¢æ¿æ ·å¼ */
        #notes-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 320px;
            height: 100%;
            background: white;
            z-index: 1000;
            overflow-y: auto;
            border-right: 1px solid #e0e0e0;
            box-shadow: 2px 0 8px rgba(0,0,0,0.1);
            font-family: -apple-system, BlinkMacSystemFont, sans-serif;
        }

        .notes-header {
            padding: 16px 20px;
            border-bottom: 1px solid #e0e0e0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: #fafafa;
            position: sticky;
            top: 0;
            z-index: 1;
        }

        .notes-header h3 {
            margin: 0;
            font-size: 16px;
            font-weight: 600;
            color: #333;
        }

        .notes-header-actions {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .notes-action-btn {
            border: none;
            padding: 4px 10px;
            border-radius: 4px;
            font-size: 12px;
            cursor: pointer;
            background: #f0f0f0;
            color: #444;
        }

        .notes-action-btn:hover {
            background: #e0e0e0;
        }

        .notes-close-btn {
            background: none;
            border: none;
            font-size: 20px;
            cursor: pointer;
            color: #666;
            padding: 4px 8px;
            border-radius: 4px;
            transition: background 0.2s;
        }

        .notes-close-btn:hover {
            background: rgba(0,0,0,0.08);
        }

        .notes-list {
            padding: 12px;
        }

        .note-item {
            background: #f8f9fa;
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 12px;
            cursor: pointer;
            transition: all 0.2s ease;
            border: 1px solid #e9ecef;
        }

        .note-item:hover {
            background: #e9ecef;
            transform: translateX(2px);
            border-color: #1976d2;
        }

        .note-text {
            font-size: 13px;
            color: #666;
            margin-bottom: 8px;
            padding: 8px;
            background: rgba(255, 213, 79, 0.2);
            border-radius: 4px;
            border-left: 3px solid #FFD54F;
            line-height: 1.5;
            max-height: 60px;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .note-content {
            font-size: 14px;
            color: #333;
            line-height: 1.6;
            margin-bottom: 8px;
            cursor: text;
            padding: 4px 6px;
            border-radius: 4px;
            transition: all 0.2s;
            min-height: 20px;
        }

        .note-content:hover {
            background: rgba(0, 0, 0, 0.03);
        }

        .note-content:focus {
            outline: none;
            background: white;
            box-shadow: 0 0 0 2px rgba(255, 213, 79, 0.5);
        }

        .note-content.editing {
            background: white;
            box-shadow: 0 0 0 2px rgba(255, 213, 79, 0.5);
        }

        .note-time {
            font-size: 11px;
            color: #999;
        }

        .notes-empty {
            text-align: center;
            padding: 40px 20px;
            color: #999;
        }

        .notes-empty-icon {
            font-size: 48px;
            margin-bottom: 12px;
        }

        .note-delete-btn {
            float: right;
            background: none;
            border: none;
            color: #999;
            cursor: pointer;
            font-size: 14px;
            padding: 2px 6px;
            border-radius: 4px;
            transition: all 0.2s;
        }

        .note-delete-btn:hover {
            background: #fee2e2;
            color: #ef4444;
        }

        /* æ–°å»ºç¬”è®°ç¼–è¾‘åŒºåŸŸæ ·å¼ */
        .note-editor {
            background: #fffef5;
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 16px;
            border: 2px solid #FFD54F;
            box-shadow: 0 2px 8px rgba(255, 213, 79, 0.3);
        }

        .note-editor-highlight {
            font-size: 13px;
            color: #666;
            margin-bottom: 10px;
            padding: 8px;
            background: rgba(255, 213, 79, 0.3);
            border-radius: 4px;
            border-left: 3px solid #FFD54F;
            line-height: 1.5;
            max-height: 80px;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .note-editor-textarea {
            width: 100%;
            min-height: 100px;
            border: 1px solid #e0e0e0;
            border-radius: 6px;
            padding: 10px;
            font-size: 14px;
            font-family: -apple-system, BlinkMacSystemFont, sans-serif;
            resize: vertical;
            outline: none;
            transition: border-color 0.2s;
            box-sizing: border-box;
        }

        .note-editor-textarea:focus {
            border-color: #FFD54F;
            box-shadow: 0 0 0 2px rgba(255, 213, 79, 0.2);
        }

        .note-editor-actions {
            display: flex;
            gap: 8px;
            margin-top: 10px;
            justify-content: flex-end;
        }

        .note-editor-btn {
            padding: 8px 16px;
            border-radius: 6px;
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
        }

        .note-editor-btn.save {
            background: #FFD54F;
            border: none;
            color: #333;
        }

        .note-editor-btn.save:hover {
            background: #FFC107;
        }

        .note-editor-btn.cancel {
            background: white;
            border: 1px solid #ddd;
            color: #666;
        }

        .note-editor-btn.cancel:hover {
            background: #f5f5f5;
        }

        .note-editor-label {
            font-size: 12px;
            color: #999;
            margin-bottom: 6px;
        }

        /* ç¬”è®°é¢œè‰²é€‰æ‹©å™¨ */
        .note-color-picker {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 10px 0;
            padding: 8px 0;
        }

        .note-color-picker-label {
            font-size: 12px;
            color: #666;
            flex-shrink: 0;
        }

        .note-color-options {
            display: flex;
            gap: 8px;
        }

        .note-color-btn {
            width: 28px;
            height: 28px;
            border-radius: 50%;
            cursor: pointer;
            border: 2px solid transparent;
            transition: all 0.15s ease;
            flex-shrink: 0;
            box-shadow: 0 2px 6px rgba(0,0,0,0.15);
        }

        .note-color-btn:hover {
            transform: scale(1.15);
        }

        .note-color-btn.selected {
            border-color: #333;
            transform: scale(1.1);
            box-shadow: 0 2px 8px rgba(0,0,0,0.25);
        }
    </style>
</head>
<body>
    <!-- ä»˜è´¹éªŒè¯è„šæœ¬ - å¿…é¡»åœ¨é¡µé¢åŠ è½½å‰æ‰§è¡Œ -->
    <script>
        (function() {
            // æ£€æŸ¥æ˜¯å¦ä¸ºå¼€å‘æ¨¡å¼
            const isDevMode = window.location.hostname === 'localhost' || 
                            window.location.hostname === '127.0.0.1' || 
                            window.location.protocol === 'file:';
            
            if (isDevMode) {
                console.log('ğŸ”“ å¼€å‘æ¨¡å¼ï¼šè·³è¿‡ä»˜è´¹éªŒè¯');
                localStorage.setItem('isPremiumUser', 'true');
                return;
            }
            
            // æ£€æŸ¥ç”¨æˆ·æ˜¯å¦ä¸ºä»˜è´¹ç”¨æˆ·
            const isPremiumUser = localStorage.getItem('isPremiumUser') === 'true';
            
            if (!isPremiumUser) {
                // éä»˜è´¹ç”¨æˆ·ï¼Œé‡å®šå‘å›é¦–é¡µ
                console.log('ğŸ”’ æœªä»˜è´¹ç”¨æˆ·å°è¯•è®¿é—®é˜…è¯»å™¨ï¼Œé‡å®šå‘è‡³é¦–é¡µ');
                alert('ğŸ”’ æ­¤åŠŸèƒ½éœ€è¦ä»˜è´¹åæ‰èƒ½ä½¿ç”¨\nè¯·å…ˆåœ¨é¦–é¡µè´­ä¹°å®Œæ•´ç‰ˆ');
                window.location.href = '../index.html';
            } else {
                console.log('âœ… ä»˜è´¹ç”¨æˆ·éªŒè¯é€šè¿‡ï¼Œå…è®¸è®¿é—®é˜…è¯»å™¨');
            }
        })();
    </script>
    
    <div id="top-bar" class="auto-hide">
        <div id="top-bar-left">
            <button id="backHomeBtn" class="top-button">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="black" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <line x1="3" y1="12" x2="21" y2="12"></line>
                    <line x1="3" y1="6" x2="21" y2="6"></line>
                    <line x1="3" y1="18" x2="21" y2="18"></line>
                </svg>
                <span>ç›®å½•</span>
            </button>
            
            <div class="theme-switcher">
                <button class="theme-button" id="theme-toggle">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10c1.84 0 3.55-.64 4.9-1.69L12 12V2zm0 10l5.9 5.9C16.55 19.36 14.84 20 13 20c-4.41 0-8-3.59-8-8 0-1.84.64-3.55 1.69-4.9L12 12z"/>
                    </svg>
                    <span>ä¸»é¢˜</span>
                </button>
                <div class="theme-dropdown" id="theme-dropdown">
                    <button class="theme-option" data-theme="default">
                        <div class="theme-preview" style="background: linear-gradient(45deg, #f0f0f0, #ffffff);"></div>
                        <span class="theme-name">é»˜è®¤</span>
                    </button>
                    <button class="theme-option" data-theme="ink">
                        <div class="theme-preview" style="background: linear-gradient(45deg, #e8e8e8, #f5f5f5);"></div>
                        <span class="theme-name">ç°ç™½</span>
                    </button>
                    <button class="theme-option" data-theme="blue">
                        <div class="theme-preview" style="background: linear-gradient(45deg, #1a365d, #2c5282);"></div>
                        <span class="theme-name">æµ…è“</span>
                    </button>
                    <button class="theme-option" data-theme="purple">
                        <div class="theme-preview" style="background: linear-gradient(45deg, #553c9a, #7c3aed);"></div>
                        <span class="theme-name">æµ…ç´«</span>
                    </button>
                    <button class="theme-option" data-theme="green">
                        <div class="theme-preview" style="background: linear-gradient(45deg, #166534, #16a34a);"></div>
                        <span class="theme-name">æµ…ç»¿</span>
                    </button>
                    <button class="theme-option" data-theme="warm">
                        <div class="theme-preview" style="background: linear-gradient(45deg, #9a3412, #ea580c);"></div>
                        <span class="theme-name">æš–è‰²</span>
                    </button>
                    <button class="theme-option" data-theme="pink">
                        <div class="theme-preview" style="background: linear-gradient(45deg, #ec4899, #f472b6);"></div>
                        <span class="theme-name">ç²‰è‰²</span>
                    </button>
                </div>
            </div>
            
            <button id="notes-btn" class="top-button">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path>
                    <polyline points="14 2 14 8 20 8"></polyline>
                    <line x1="16" y1="13" x2="8" y2="13"></line>
                    <line x1="16" y1="17" x2="8" y2="17"></line>
                    <polyline points="10 9 9 9 8 9"></polyline>
                </svg>
                <span>ç¬”è®°</span>
            </button>
        </div>
        
        <div id="top-bar-center">
            <div id="search-container" class="search-container">
                <svg width="16" height="16" viewBox="0 0 24 24" class="search-icon">
                    <path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"/>
                </svg>
                <input type="text" id="search-input" placeholder="æœç´¢" />
                <div id="search-info"></div>
            </div>
        </div>
        
        <div id="top-bar-right">
            <button id="cut-btn" class="top-button" title="å¼€å¯åï¼Œæ‹–å…¥ç”µå­ä¹¦å°†è‡ªåŠ¨åˆ‡ä¹¦å¹¶ä¸‹è½½">
                <svg id="cut-btn-icon" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="black" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M14.7 6.3a1 1 0 0 0 0 1.4l1.6 1.6a1 1 0 0 0 1.4 0l3.77-3.77a6 6 0 0 1-7.94 7.94l-6.91 6.91a2.12 2.12 0 0 1-3-3l6.91-6.91a6 6 0 0 1 7.94-7.94l-3.76 3.76z"></path>
                </svg>
                <span>åˆ‡ä¹¦</span>
            </button>
            <label for="file-input" id="file-input-container" class="top-button">
                <svg width="16" height="16" viewBox="0 0 24 24">
                    <path d="M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z"/>
                </svg>
                <span>æ‰“å¼€ç”µå­ä¹¦</span>
            </label>
            <input type="file" id="file-input" accept=".epub" style="display:none;" />
        </div>
    </div>
    <div id="main-container">
        <button id="prev-button" class="nav-button">
            <svg viewBox="0 0 24 24">
                <path d="M15.41 7.41L14 6l-6 6 6 6 1.41-1.41L10.83 12z"/>
            </svg>
        </button>
        
        <div id="viewer">
            <!-- æ‹–æ‹½ä¸Šä¼ åŒºåŸŸ -->
            <div id="upload-area" class="upload-area">
                <div class="upload-content">
                    <img src="public/image.png" alt="Book Icon" class="upload-icon">
                    <h2 class="upload-title">Drag and drop the ebook you want to read here!</h2>
                    <label for="file-input" class="upload-subtitle">Open File</label>
                    <p class="upload-subtitle" style="margin-top: 5px;" onclick="event.stopPropagation(); window.open('http://localhost:3004', '_blank')">Open TubeScript Splitter</p>
                    <p class="upload-formats">Supports .epub</p>
                </div>
            </div>

            <!-- å·¦å³ç®­å¤´æŒ‰é’®ï¼ˆå¯ç‚¹å‡»ï¼‰ -->
            <button class="arrow-button left" id="arrow-prev" aria-label="ä¸Šä¸€é¡µ" title="ä¸Šä¸€é¡µ">
                <svg viewBox="0 0 24 24" aria-hidden="true">
                    <path fill="currentColor" d="M15.41 7.41L14 6l-6 6 6 6 1.41-1.41L10.83 12z"/>
                </svg>
            </button>
            <button class="arrow-button right" id="arrow-next" aria-label="ä¸‹ä¸€é¡µ" title="ä¸‹ä¸€é¡µ">
                <svg viewBox="0 0 24 24" aria-hidden="true">
                    <path fill="currentColor" d="M8.59 16.59 10 18l6-6-6-6-1.41 1.41L13.17 12z"/>
                </svg>
            </button>
        </div>
        
        <button id="next-button" class="nav-button">
            <svg viewBox="0 0 24 24">
                <path d="M10 6L8.59 7.41 13.17 12l-4.58 4.59L10 18l6-6z"/>
            </svg>
        </button>
    </div>

    <script>
        const fileInput = document.getElementById('file-input');
        const fileInputContainer = document.getElementById('file-input-container');
        const prevButton = document.getElementById('prev-button');
        const nextButton = document.getElementById('next-button');
        const uploadArea = document.getElementById('upload-area');
        
        // ä½¿ç”¨ label å…ƒç´ è‡ªåŠ¨è§¦å‘ file inputï¼Œæ— éœ€é¢å¤– JS
        const uploadContent = document.querySelector('.upload-content');
        const arrowPrev = document.getElementById('arrow-prev');
        const arrowNext = document.getElementById('arrow-next');
        const viewerEl = document.getElementById('viewer');
        const topBarEl = document.getElementById('top-bar');
        let book = null;
        let rendition = null;
        let pageTurn = null;

        // ç›‘å¬æ–‡ä»¶é€‰æ‹©
        fileInput.addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (!file || !file.name.endsWith('.epub')) {
                alert('è¯·é€‰æ‹© EPUB æ–‡ä»¶');
                return;
            }
            // æ€»æ˜¯åŠ è½½ä¹¦ç±
            await loadBook(file);
            
            // å¦‚æœå¼€å¯äº†åˆ‡ä¹¦æ¨¡å¼ï¼Œåˆ™å¤„ç†
            if (isAutoCutEnabled) {
                processAndDownload(file);
            }
            
            // é‡ç½® file inputï¼Œå…è®¸é‡æ–°é€‰æ‹©åŒä¸€ä¸ªæ–‡ä»¶
            fileInput.value = '';
        });

        // åŠ è½½ç”µå­ä¹¦å‡½æ•°
        async function loadBook(file) {
            // å¦‚æœå·²ç»æœ‰ä¹¦åœ¨æ˜¾ç¤ºï¼Œå…ˆæ¸…é™¤
            if (book) {
                book.destroy();
            }

            try {
                // éšè—ä¸Šä¼ åŒºåŸŸ
                uploadArea.classList.add('hidden');

                // åˆ›å»ºæ–°çš„ç”µå­ä¹¦å®ä¾‹
                book = ePub();
                await book.open(file);

                // æ¸²æŸ“ç”µå­ä¹¦
                rendition = book.renderTo('viewer', {
                    width: '100%',
                    height: '100%',
                    flow: 'paginated',
                    spread: 'none',
                    manager: 'default'
                });

                await rendition.display();

                // è®¾ç½®æ ·å¼
                rendition.themes.default({
                    'body': {
                        'padding': '0',
                        'margin': '0'
                    },
                    'p': {
                        'font-family': '-apple-system, BlinkMacSystemFont, "SF Pro Text", sans-serif',
                        'font-size': '16px',
                        'line-height': '1.6',
                        'margin': '1em 0'
                    },
                    'img': {
                        'max-width': '50%'
                    }
                });

                // Initialize Highlight Manager
                if (window.HighlightManager) {
                    window.highlightManager = new window.HighlightManager(rendition);
                }

                // åº”ç”¨å½“å‰ä¸»é¢˜åˆ°æ–°åŠ è½½çš„ç”µå­ä¹¦
                if (themeManager) {
                    themeManager.applyThemeToReader(themeManager.currentTheme);
                }

                // éšè—æ—§çš„å¤§å¯¼èˆªæŒ‰é’®ï¼Œé¿å…å¹²æ‰°
                prevButton.style.display = 'none';
                nextButton.style.display = 'none';

                // åˆå§‹åŒ–å•æ¬¡ç¿»é¡µä¸æ·¡å…¥æ·¡å‡º
                if (window.PageTurn) {
                    if (pageTurn && pageTurn.destroy) pageTurn.destroy();
                    pageTurn = new window.PageTurn(rendition, {
                        gain: 80,
                        thresholdPx: 40,
                        commitDelay: 120,
                        cooldownMs: 350,
                        fadeDuration: 200
                    });
                    console.log('âœ… ç¿»é¡µç³»ç»Ÿå·²å¯ç”¨');
                }

                // åŠ è½½ç›®å½•
                try {
                    console.log('æ–‡ä»¶åŠ è½½æ—¶å¼€å§‹åŠ è½½ç›®å½•...');
                    
                    // å°è¯•å¤šç§æ–¹å¼è·å–ç›®å½•
                    if (book.loaded && book.loaded.navigation) {
                        toc = await book.loaded.navigation;
                    } else if (book.navigation) {
                        toc = await book.navigation;
                    } else if (book.toc) {
                        toc = await book.toc;
                    } else {
                        // å°è¯•ç›´æ¥è·å–ç›®å½•
                        const ready = await book.ready;
                        if (ready && ready.navigation) {
                            toc = ready.navigation;
                        }
                    }
                    
                    console.log('æ–‡ä»¶åŠ è½½æ—¶ç›®å½•åŠ è½½æˆåŠŸ:', toc);
                } catch (error) {
                    console.log('è¯¥ç”µå­ä¹¦æ²¡æœ‰ç›®å½•æˆ–ç›®å½•åŠ è½½å¤±è´¥:', error);
                }

            } catch (error) {
                console.error('Error loading book:', error);
                alert('åŠ è½½ç”µå­ä¹¦æ—¶å‡ºé”™');
                // æ˜¾ç¤ºé”™è¯¯æ—¶é‡æ–°æ˜¾ç¤ºä¸Šä¼ åŒºåŸŸ
                uploadArea.classList.remove('hidden');
            }
        }

        // é€šç”¨å¯¼èˆªå‡½æ•°ï¼ˆä¼˜å…ˆ PageTurnï¼Œç¡®ä¿ä¸è¿ç¿»ï¼‰
        function handleNav(dir) {
            if (!rendition) return;
            if (pageTurn && !pageTurn.locked && !pageTurn.isAnimating && typeof pageTurn.turnPage === 'function') {
                pageTurn.turnPage(dir);
            } else {
                if (dir === 'next') rendition.next(); else rendition.prev();
            }
        }

        // å¤§æŒ‰é’®ï¼ˆå·²éšè—ï¼‰ä»ä¿ç•™è¡Œä¸º
        prevButton.addEventListener('click', () => handleNav('prev'));
        nextButton.addEventListener('click', () => handleNav('next'));

        // å°ç®­å¤´æŒ‰é’®äº‹ä»¶
        arrowPrev.addEventListener('click', (e) => { e.stopPropagation(); handleNav('prev'); });
        arrowNext.addEventListener('click', (e) => { e.stopPropagation(); handleNav('next'); });
        [arrowPrev, arrowNext].forEach(btn => btn.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); btn.click(); }
        }));

        // ====== åŸºäºé¼ æ ‡ä½ç½®çš„æ˜¾ç¤º/éšè—ï¼ˆé¡¶éƒ¨æ  + å·¦å³ç®­å¤´ï¼‰======
        (function setupHoverUI(){
            const EDGE_TRIGGER = 96; // å·¦å³è§¦å‘èŒƒå›´(px)
            const TOP_TRIGGER = 24;  // é¡¶éƒ¨è§¦å‘èŒƒå›´(px)
            let hideTopTimer = null;
            const boundIframes = new WeakSet();
            
            // ä¾› iframe ä½¿ç”¨çš„é”®ç›˜å¤„ç†å™¨
            function onIframeKeyUp(e){
                if (!rendition) return;
                if (e.key === 'ArrowLeft') {
                    e.preventDefault && e.preventDefault();
                    handleNav('prev');
                } else if (e.key === 'ArrowRight') {
                    e.preventDefault && e.preventDefault();
                    handleNav('next');
                }
            }

            function updateUIFromXY(clientX, clientY){
                const rect = viewerEl.getBoundingClientRect();
                const x = clientX, y = clientY;
                const withinY = y >= rect.top && y <= rect.bottom;
                const withinX = x >= rect.left && x <= rect.right;
                const nearLeft = withinY && (x - rect.left) <= EDGE_TRIGGER;
                const nearRight = withinY && (rect.right - x) <= EDGE_TRIGGER;
                viewerEl.classList.toggle('show-left', nearLeft);
                viewerEl.classList.toggle('show-right', nearRight);

                const nearTop = withinX && (y - rect.top) <= TOP_TRIGGER;
                if (nearTop || topBarEl.matches(':hover')) {
                    topBarEl.classList.add('show');
                    if (hideTopTimer) { clearTimeout(hideTopTimer); hideTopTimer = null; }
                } else {
                    if (!hideTopTimer) hideTopTimer = setTimeout(()=> topBarEl.classList.remove('show'), 400);
                }
            }

            function updateUI(e){
                updateUIFromXY(e.clientX, e.clientY);
            }

            // ç»‘å®šåˆ°é¡¶å±‚æ–‡æ¡£
            document.addEventListener('mousemove', updateUI, { passive: true });

            // ä¹Ÿç»‘å®šåˆ° ePub çš„ iframe å†…éƒ¨ï¼ˆæŠŠåæ ‡æ¢ç®—åˆ°é¡¶å±‚ï¼‰
            function attachFrame(iframe){
                if (!iframe || boundIframes.has(iframe)) return;
                try {
                    const win = iframe.contentWindow;
                    const doc = iframe.contentDocument;
                    const mapAndUpdate = (fe) => {
                        const r = iframe.getBoundingClientRect();
                        updateUIFromXY(r.left + fe.clientX, r.top + fe.clientY);
                    };
                    win.addEventListener('mousemove', mapAndUpdate, { passive: true });
                    doc.addEventListener('mousemove', mapAndUpdate, { passive: true });
                    // ç¦»å¼€ iframe æ—¶é‡ç½®
                    win.addEventListener('mouseleave', () => viewerEl.classList.remove('show-left','show-right'), { passive: true });
                    doc.addEventListener('mouseleave', () => viewerEl.classList.remove('show-left','show-right'), { passive: true });
                    // åœ¨ iframe å†…éƒ¨ä¹Ÿæ”¯æŒå·¦å³æ–¹å‘é”®ç¿»é¡µ
                    win.addEventListener('keyup', onIframeKeyUp, false);
                    doc.addEventListener('keyup', onIframeKeyUp, false);
                    boundIframes.add(iframe);
                } catch (err) {
                    // å¿½ç•¥è·¨åŸŸç­‰å¼‚å¸¸
                }
            }

            function attachAllFrames(){
                viewerEl.querySelectorAll('iframe').forEach(attachFrame);
            }
            attachAllFrames();

            // è§‚å¯Ÿ iframe å˜åŒ–ï¼ˆç« èŠ‚åˆ‡æ¢ä¼šé‡å»ºï¼‰
            const mo = new MutationObserver(() => attachAllFrames());
            mo.observe(viewerEl, { childList: true, subtree: true });

            viewerEl.addEventListener('mouseleave', () => {
                viewerEl.classList.remove('show-left','show-right');
                setTimeout(()=> topBarEl.classList.remove('show'), 300);
            });
        })();


        // ==========================================
        // åˆ‡ä¹¦åŠŸèƒ½ï¼ˆåˆå¹¶äº†åŸæ¥çš„è‡ªåŠ¨åˆ‡ä¹¦åŠŸèƒ½ï¼‰
        // ==========================================
        let isAutoCutEnabled = false;
        const cutBtn = document.getElementById('cut-btn');
        const cutBtnIcon = document.getElementById('cut-btn-icon');
        
        if (cutBtn) {
            cutBtn.addEventListener('click', () => {
                isAutoCutEnabled = !isAutoCutEnabled;
                if (isAutoCutEnabled) {
                    cutBtn.classList.add('active');
                    // å›¾æ ‡å˜é»‘è‰²
                    if (cutBtnIcon) {
                        cutBtnIcon.setAttribute('stroke', 'black');
                    }
                    // Show a toast notification
                    const toast = document.createElement('div');
                    toast.style.cssText = 'position:fixed;top:80px;right:20px;background:rgba(0,0,0,0.85);color:white;padding:12px 24px;border-radius:8px;box-shadow:0 4px 12px rgba(0,0,0,0.15);z-index:10000;animation:fadeIn 0.3s ease;backdrop-filter:blur(10px);';
                    toast.innerHTML = 'âœ… åˆ‡ä¹¦æ¨¡å¼å·²å¼€å¯<div style="font-size:12px;margin-top:4px;opacity:0.9;">æ‹–å…¥ç”µå­ä¹¦å°†è‡ªåŠ¨æ‰“å¼€å¹¶åˆ‡ä¹¦ä¸‹è½½</div>';
                    document.body.appendChild(toast);
                    setTimeout(() => {
                        toast.style.opacity = '0';
                        toast.style.transition = 'opacity 0.5s';
                        setTimeout(() => document.body.removeChild(toast), 500);
                    }, 3000);
                } else {
                    cutBtn.classList.remove('active');
                    // å›¾æ ‡ä¿æŒé»‘è‰²
                    if (cutBtnIcon) {
                        cutBtnIcon.setAttribute('stroke', 'black');
                    }
                }
            });
        }

        // å…¨å±€æ‹–æ‹½äº‹ä»¶å¤„ç† (è¦†ç›–åŸæœ‰çš„ uploadArea å¤„ç†ï¼Œæ”¯æŒæ•´ä¸ªé¡µé¢æ‹–æ‹½)
        document.addEventListener('dragover', (e) => {
            e.preventDefault();
            e.stopPropagation();
        }, true);

        document.addEventListener('drop', async (e) => {
            // å¿½ç•¥æ¥è‡ªå†…éƒ¨å…ƒç´ çš„æ‹–æ‹½
            if (e.dataTransfer.types.includes('text/plain') && !e.dataTransfer.types.includes('Files')) {
                return;
            }

            e.preventDefault();
            e.stopPropagation();
            
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                const file = files[0];
                if (file.name.endsWith('.epub')) {
                    // æ€»æ˜¯æ‰“å¼€ä¹¦
                    await loadBook(file);
                    
                    // å¦‚æœå¼€å¯äº†è‡ªåŠ¨åˆ‡ä¹¦ï¼Œåˆ™å¤„ç†
                    if (isAutoCutEnabled) {
                        processAndDownload(file);
                    }
                } else {
                    // Only alert if dropped on the viewer, to avoid annoying alerts for random drops elsewhere
                    // But here we want to be helpful.
                    // alert('è¯·é€‰æ‹© EPUB æ–‡ä»¶'); 
                }
            }
        }, true);

        async function processAndDownload(file) {
            const statusMsg = document.createElement('div');
            statusMsg.style.cssText = 'position:fixed;top:0px;right:24px;transform:none;background:rgba(0,0,0,0.86);color:white;padding:14px 18px;border-radius:12px;z-index:10000;backdrop-filter:blur(10px);min-width:180px;max-width:220px;box-shadow:0 8px 24px rgba(0,0,0,0.25);font-size:13px;pointer-events:none;display:flex;align-items:center;gap:12px;';
            statusMsg.innerHTML = '<div style="width:32px;height:32px;border:3px solid rgba(59,130,246,0.3);border-top-color:#3b82f6;border-radius:50%;flex-shrink:0;animation:spin 1s linear infinite;"></div><div style="font-weight:600;color:#60a5fa;font-size:14px;line-height:1.4;">æ­£åœ¨æ–½å±•åˆ‡ä¹¦ç¥æŠ€...</div>';
            document.body.appendChild(statusMsg);
            
            // Add spin animation if not exists
            if (!document.getElementById('spin-animation-style')) {
                const style = document.createElement('style');
                style.id = 'spin-animation-style';
                style.textContent = '@keyframes spin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }';
                document.head.appendChild(style);
            }

            try {
                // æ£€æµ‹APIç«¯ç‚¹ï¼šä¼˜å…ˆä½¿ç”¨ç¯å¢ƒå˜é‡æˆ–é…ç½®çš„å¤–éƒ¨APIï¼Œå¦åˆ™ä½¿ç”¨æœ¬åœ°API
                // å¯ä»¥é€šè¿‡åœ¨é¡µé¢ä¸­æ·»åŠ  script æ ‡ç­¾è®¾ç½® window.CUTTING_API_URL æ¥é…ç½®
                // åç«¯æ”¹ä¸º Render è‡ªæ‰˜ç®¡æœåŠ¡ï¼šç›´æ¥ multipart ä¸Šä¼ ï¼Œä¸å†èµ° Vercel Blob
                const API_BASE_URL = window.CUTTING_API_URL || 
                                    (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1' 
                                        ? '' 
                                        : 'https://tobooks.onrender.com');
                
                const uploadUrl = API_BASE_URL ? `${API_BASE_URL}/upload` : '/upload';
                
                console.log('ä¸Šä¼ æ–‡ä»¶åˆ°:', uploadUrl);
                console.log('æ–‡ä»¶ä¿¡æ¯:', file.name, file.size, 'bytes');
                
                const formData = new FormData();
                formData.append('file', file);

                const res = await fetch(uploadUrl, { 
                    method: 'POST', 
                    body: formData,
                });
                
                console.log('æ”¶åˆ°å“åº”:', res.status, res.statusText);
                if (!res.ok) {
                    throw new Error('åˆ‡ä¹¦æœåŠ¡å™¨è¿”å›é”™è¯¯çŠ¶æ€ï¼š' + res.status);
                }
                const data = await res.json();
                if (!data || !data.success || !data.outputDir) {
                    throw new Error(data && data.error ? data.error : 'åˆ‡ä¹¦æœåŠ¡å™¨è¿”å›æ•°æ®å¼‚å¸¸');
                }

                statusMsg.innerHTML = '<div style="width:32px;height:32px;border:3px solid rgba(59,130,246,0.3);border-top-color:#3b82f6;border-radius:50%;flex-shrink:0;animation:spin 1s linear infinite;"></div><div style="font-weight:600;color:#60a5fa;font-size:14px;line-height:1.4;">æ­£åœ¨æ‰“åŒ…ç« èŠ‚...</div>';

                const baseName = file.name.replace(/\.epub$/i, '');
                const currentApiBaseUrl = API_BASE_URL;
                const downloadUrl = currentApiBaseUrl 
                    ? `${currentApiBaseUrl}/download?path=${encodeURIComponent(data.outputDir)}`
                    : `/download?path=${encodeURIComponent(data.outputDir)}`;

                const a = document.createElement('a');
                a.href = downloadUrl;
                a.download = `${baseName}.zip`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);

                statusMsg.innerHTML = '<div style="color:#4caf50;font-size:24px;flex-shrink:0;">âœ…</div><div style="font-weight:600;color:#4caf50;font-size:14px;line-height:1.4;">åˆ‡ä¹¦å®Œæˆï¼ŒZIP å·²å¼€å§‹ä¸‹è½½</div>';
                setTimeout(() => document.body.removeChild(statusMsg), 2500);
            } catch (error) {
                console.error('Cutting failed:', error);
                statusMsg.innerHTML = '<div style="color:#f44336;font-size:24px;flex-shrink:0;">âŒ</div><div style="font-weight:600;color:#f44336;font-size:14px;line-height:1.4;"><div>åˆ‡ä¹¦å¤±è´¥</div><div style="font-size:12px;opacity:0.9;margin-top:4px;">'+(error.message || 'è¯·æ£€æŸ¥åˆ‡ä¹¦æœåŠ¡å™¨æ˜¯å¦å·²å¯åŠ¨')+'</div></div>';
                setTimeout(() => document.body.removeChild(statusMsg), 3500);
            }
        }

        // Helper function to extract chapter title like the script
        function extractChapterTitle(doc, index) {
            let title = '';
            
            // Try to extract from content first (like script's pandoc conversion)
            const body = doc.body;
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = body.innerHTML;
            
            // Look for common chapter patterns in the first few lines
            const textContent = tempDiv.textContent || '';
            const lines = textContent.split('\n').slice(0, 10);
            
            for (let line of lines) {
                line = line.trim();
                if (!line) continue;
                
                // Check for chapter patterns
                if (/^[0-9]+\s+.*|^ç¬¬[ä¸€äºŒä¸‰å››äº”å…­ä¸ƒå…«ä¹åç™¾åƒä¸‡ç”²ä¹™ä¸™ä¸æˆŠå·±åºšè¾›å£¬ç™¸]+[ç« èŠ‚å›].*|^Chapter\s+.*|^ç›®å½•|^åºè¨€|^å‰è¨€|^åè®°|^é™„å½•/.test(line)) {
                    title = line;
                    break;
                }
            }
            
            // If no pattern found, try the first non-empty line
            if (!title) {
                for (let line of lines) {
                    line = line.trim();
                    if (line) {
                        title = line;
                        break;
                    }
                }
            }
            
            // If still no title, try HTML tags
            if (!title) {
                const titleTag = doc.querySelector('title');
                if (titleTag) title = titleTag.textContent;
                
                if (!title) {
                    const heading = doc.querySelector('h1, h2, h3, h4, h5, h6');
                    if (heading) title = heading.textContent;
                }
            }
            
            // Clean the title for filename
            if (title) {
                title = title.replace(/<[^>]*>/g, '') // Remove HTML tags
                           .replace(/^\s*|\s*$/g, '') // Trim whitespace
                           .replace(/[\/\*\?:<>"|]/g, '_') // Replace problematic chars
                           .replace(/\s+/g, '_') // Replace spaces with underscores
                           .substring(0, 100); // Limit length
            }
            
            // If title is empty or only punctuation, use default
            if (!title || /^[\p{P}_]+$/.test(title)) {
                title = `untitled_split_${String(index + 1).padStart(3, '0')}`;
            }
            
            return title;
        }

        // Helper function to convert to plain text like script
        function convertToPlainText(body) {
            let text = body.textContent || body.innerText || '';
            
            // Clean up like the script's clean_markdown function
            text = text.replace(/<[^>]*>/g, '') // Remove HTML tags
                      .replace(/^\s*$/gm, '') // Remove empty lines
                      .replace(/^\s*|\s*$/gm, ''); // Trim each line
            
            return text.trim();
        }

        // Helper function to convert to markdown like pandoc
        function convertToMarkdown(body, imagesFolder) {
            let markdown = '';
            
            // Process each element like pandoc would
            const elements = body.querySelectorAll('*');
            const imageCounter = { count: 1 };
            
            elements.forEach(element => {
                const tagName = element.tagName.toLowerCase();
                const text = element.textContent.trim();
                
                if (!text && tagName !== 'img') return;
                
                switch (tagName) {
                    case 'h1':
                        markdown += `# ${text}\n\n`;
                        break;
                    case 'h2':
                        markdown += `## ${text}\n\n`;
                        break;
                    case 'h3':
                        markdown += `### ${text}\n\n`;
                        break;
                    case 'h4':
                        markdown += `#### ${text}\n\n`;
                        break;
                    case 'h5':
                        markdown += `##### ${text}\n\n`;
                        break;
                    case 'h6':
                        markdown += `###### ${text}\n\n`;
                        break;
                    case 'p':
                        // Handle images in paragraphs
                        const images = element.querySelectorAll('img');
                        if (images.length > 0) {
                            images.forEach(img => {
                                const src = img.src || img.getAttribute('data-src');
                                if (src) {
                                    const imgName = `image_${imageCounter.count++}.png`;
                                    markdown += `![${img.alt || imgName}](images/${imgName})\n\n`;
                                }
                            });
                        }
                        markdown += `${text}\n\n`;
                        break;
                    case 'img':
                        const src = element.src || element.getAttribute('data-src');
                        if (src) {
                            const imgName = `image_${imageCounter.count++}.png`;
                            markdown += `![${element.alt || imgName}](images/${imgName})\n\n`;
                        }
                        break;
                    case 'ul':
                        const listItems = element.querySelectorAll('li');
                        listItems.forEach(li => {
                            markdown += `- ${li.textContent.trim()}\n`;
                        });
                        markdown += '\n';
                        break;
                    case 'ol':
                        const olItems = element.querySelectorAll('li');
                        olItems.forEach((li, index) => {
                            markdown += `${index + 1}. ${li.textContent.trim()}\n`;
                        });
                        markdown += '\n';
                        break;
                    case 'blockquote':
                        markdown += `> ${text}\n\n`;
                        break;
                    case 'code':
                        markdown += `\`${text}\`\n\n`;
                        break;
                    case 'pre':
                        markdown += `\`\`\`\n${text}\n\`\`\`\n\n`;
                        break;
                    case 'div':
                    case 'section':
                    case 'article':
                        // Just add text content for structural elements
                        if (text) {
                            markdown += `${text}\n\n`;
                        }
                        break;
                    default:
                        // For other elements, just add text
                        if (text && element.children.length === 0) {
                            markdown += `${text}\n\n`;
                        }
                }
            });
            
            return markdown.trim();
        }

        // Create index files like the script
        function createIndexFiles(mdFolder, txtFolder, tocEntries, bookTitle) {
            // Markdown index
            let mdIndex = `# ${bookTitle}\n\n## ç›®å½•\n\n`;
            tocEntries.forEach(entry => {
                mdIndex += `- [${entry.title}](markdown/${entry.basename}.md)\n`;
            });
            mdFolder.file('index.md', mdIndex);
            
            // TXT index
            let txtIndex = `ç›®å½•\n======\n\n`;
            tocEntries.forEach(entry => {
                txtIndex += `* ${entry.index} ${entry.title}\n`;
            });
            txtFolder.file('index.txt', txtIndex);
        }

        // Create merged documents like the script
        function createMergedDocuments(outputDir, markdownChapters, txtChapters, bookTitle) {
            // Merged Markdown with frontmatter
            let mergedMd = `---\ntitle: "${bookTitle}"\ndate: ${new Date().toISOString().split('T')[0]}\n---\n\n`;
            markdownChapters.forEach(chapter => {
                mergedMd += chapter.content + '\n\n---\n\n';
            });
            outputDir.file(`${bookTitle}.md`, mergedMd);
            
            // Merged TXT with structure
            let mergedTxt = `${bookTitle}\n================================\n\n`;
            txtChapters.forEach(chapter => {
                mergedTxt += `## ${chapter.title}\n--------------------------------\n`;
                mergedTxt += chapter.content + '\n\n\n';
            });
            outputDir.file(`${bookTitle}.txt`, mergedTxt);
        }

        // æ·»åŠ å¯¼èˆªåŒºåŸŸç‚¹å‡»äº‹ä»¶ï¼ˆæ”¯æŒåŒå‡»ç•™ç»™æ‰©å±•/ç¿»è¯‘æ’ä»¶ï¼‰
        (function setupTapNavigation(){
            let lastTapTs = 0;
            let lastTapX = 0;
            let lastTapY = 0;
            let singleTapTimer = null;
            const DBL_TAP_MS = 280; // åŒå‡»æ—¶é—´çª—å£
            const DBL_TAP_DIST = 30; // åŒå‡»ä½ç½®çª—å£

            function scheduleSingleTap(dir, target, clientX, clientY){
                if (singleTapTimer) clearTimeout(singleTapTimer);
                singleTapTimer = setTimeout(() => {
                    handleNav(dir);
                    singleTapTimer = null;
                }, DBL_TAP_MS);
            }

            function forwardDblClick(target, clientX, clientY){
                try {
                    const dbl = new MouseEvent('dblclick', {
                        bubbles: true,
                        cancelable: true,
                        clientX, clientY
                    });
                    // åœ¨ç›®æ ‡ä¸æ–‡æ¡£ä¸Šéƒ½æ´¾å‘ï¼Œæå‡å…¼å®¹æ€§
                    target && target.dispatchEvent(dbl);
                    document.dispatchEvent(dbl);
                    window.dispatchEvent(dbl);
                } catch {}
            }

            document.addEventListener('click', (e) => {
                if (!rendition) return;
                // é¿å…ä¸æŒ‰é’®ç‚¹å‡»å†²çª
                if (e.target.closest('.nav-button') || e.target.closest('#top-bar') || e.target.closest('#toc-container')) return;

                const rect = document.getElementById('main-container').getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                const w = rect.width;
                const now = performance.now();

                const isDblTap = (now - lastTapTs) <= DBL_TAP_MS && Math.hypot(x - lastTapX, y - lastTapY) <= DBL_TAP_DIST;
                if (isDblTap) {
                    // åŒå‡»ï¼šå–æ¶ˆå•å‡»ç¿»é¡µï¼Œå‘é¡µé¢æ´¾å‘ dblclick äº¤ç»™æ‰©å±•å¤„ç†
                    if (singleTapTimer) { clearTimeout(singleTapTimer); singleTapTimer = null; }
                    forwardDblClick(e.target, e.clientX, e.clientY);
                    lastTapTs = 0;
                    return;
                }

                // è®°å½•æœ¬æ¬¡ç‚¹å‡»ï¼ˆä»…ç”¨äºåŒå‡»æ£€æµ‹ï¼‰
                lastTapTs = now; lastTapX = x; lastTapY = y;

                // å·²ç¦ç”¨å•å‡»ç¿»é¡µ - åªä¿ç•™åŒæŒ‡æ»‘åŠ¨ç¿»é¡µ
                // å¦‚éœ€æ¢å¤ç‚¹å‡»ç¿»é¡µï¼Œå–æ¶ˆä¸‹æ–¹æ³¨é‡Šï¼š
                // if (x < w * 0.25) {
                //     scheduleSingleTap('prev', e.target, e.clientX, e.clientY);
                // } else if (x > w * 0.75) {
                //     scheduleSingleTap('next', e.target, e.clientX, e.clientY);
                // }
            }, true);

            // å°† iframe å†…çš„åŒå‡»è½¬å‘åˆ°é¡¶å±‚ï¼ˆä¾¿äºæ‰©å±•æ•è·ï¼‰
            function attachDblToIframe(iframe){
                if (!iframe) return;
                try {
                    const win = iframe.contentWindow; const doc = iframe.contentDocument;
                    const forward = (fe)=>{
                        const r = iframe.getBoundingClientRect();
                        forwardDblClick(iframe, r.left + fe.clientX, r.top + fe.clientY);
                    };
                    win.addEventListener('dblclick', forward, true);
                    doc.addEventListener('dblclick', forward, true);
                } catch {}
            }
            // åˆæ¬¡ / å˜æ›´æ—¶ç»‘å®š
            const mo2 = new MutationObserver(() => {
                viewerEl.querySelectorAll('iframe').forEach(attachDblToIframe);
            });
            mo2.observe(viewerEl, { childList: true, subtree: true });
            viewerEl.querySelectorAll('iframe').forEach(attachDblToIframe);
        })();

        // é”®ç›˜äº‹ä»¶
        document.addEventListener('keyup', (e) => {
            if (!rendition) return;
            
            if (e.key === 'ArrowLeft') {
                rendition.prev();
            }
            if (e.key === 'ArrowRight') {
                rendition.next();
            }
        });

        // æœç´¢ç›¸å…³å˜é‡
        let searchResults = [];
        let currentSearchIndex = -1;

        // æœç´¢åŠŸèƒ½
        const searchInput = document.getElementById('search-input');
        const searchInfo = document.getElementById('search-info');

        // å¿«æ·é”®ç›‘å¬ (Ctrl+F æˆ– Cmd+F)
        document.addEventListener('keydown', (e) => {
            if ((e.ctrlKey || e.metaKey) && e.key === 'f') {
                e.preventDefault(); // é˜»æ­¢æµè§ˆå™¨é»˜è®¤æœç´¢
                searchInput.focus();
                searchInput.select();
            }
        });



        // æ‰§è¡Œæœç´¢
        async function performSearch(query) {
            if (!query.trim() || !book) return;

            searchResults = [];
            currentSearchIndex = -1;

            try {
                // æ¸…é™¤ä¹‹å‰çš„é«˜äº®
                clearSearchHighlights();

                // è·å–ä¹¦ç±çš„æ‰€æœ‰ç« èŠ‚
                const spine = book.spine;
                
                for (let i = 0; i < spine.length; i++) {
                    const section = spine.get(i);
                    const doc = await section.load(book.load.bind(book));
                    const text = doc.textContent || doc.innerText || '';
                    
                    // åœ¨ç« èŠ‚ä¸­æœç´¢å…³é”®è¯ - ä½¿ç”¨æ›´ç²¾å‡†çš„æœç´¢
                    const regex = new RegExp(query.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'gi');
                    let match;
                    let matchCount = 0;
                    
                    while ((match = regex.exec(text)) !== null) {
                        matchCount++;
                        
                        // éªŒè¯åŒ¹é…çš„ä¸Šä¸‹æ–‡ï¼Œç¡®ä¿æ˜¯æœ‰æ•ˆçš„åŒ¹é…
                        const contextBefore = text.substring(Math.max(0, match.index - 10), match.index);
                        const contextAfter = text.substring(match.index + match[0].length, Math.min(text.length, match.index + match[0].length + 10));
                        
                        // æ£€æŸ¥åŒ¹é…æ˜¯å¦åœ¨æœ‰æ•ˆçš„æ–‡æœ¬èŠ‚ç‚¹ä¸­
                        const textNode = findTextNodeAtPosition(doc, match.index);
                        if (textNode && isValidTextNode(textNode)) {
                            try {
                                const range = findTextRange(doc, match.index, match[0].length);
                                if (range && isValidRange(range)) {
                                    const cfi = section.cfiFromRange(range);
                                    searchResults.push({
                                        cfi: cfi,
                                        excerpt: getExcerpt(text, match.index, query.length),
                                        spineIndex: i,
                                        query: query,
                                        matchIndex: matchCount,
                                        context: {
                                            before: contextBefore,
                                            after: contextAfter
                                        }
                                    });
                                }
                            } catch (error) {
                                console.log('CFIç”Ÿæˆå¤±è´¥:', error);
                                // å¤‡ç”¨æ–¹æ¡ˆï¼šä½¿ç”¨å…ƒç´ å®šä½
                                try {
                                    const element = findElementAtIndex(doc, match.index);
                                    if (element && isValidElement(element)) {
                                        const cfi = section.cfiFromElement(element);
                                        searchResults.push({
                                            cfi: cfi,
                                            excerpt: getExcerpt(text, match.index, query.length),
                                            spineIndex: i,
                                            query: query,
                                            matchIndex: matchCount,
                                            context: {
                                                before: contextBefore,
                                                after: contextAfter
                                            }
                                        });
                                    }
                                } catch (e) {
                                    console.log('å¤‡ç”¨CFIç”Ÿæˆä¹Ÿå¤±è´¥:', e);
                                }
                            }
                        }
                    }
                }

                // æŒ‰ç« èŠ‚å’Œä½ç½®æ’åºæœç´¢ç»“æœ
                searchResults.sort((a, b) => {
                    if (a.spineIndex !== b.spineIndex) {
                        return a.spineIndex - b.spineIndex;
                    }
                    return a.matchIndex - b.matchIndex;
                });

                updateSearchInfo();
                if (searchResults.length > 0) {
                    currentSearchIndex = 0;
                    goToSearchResult(0);
                }

            } catch (error) {
                console.error('æœç´¢å‡ºé”™:', error);
            }
        }

        // æŸ¥æ‰¾æ–‡æœ¬èŒƒå›´
        function findTextRange(doc, startIndex, length) {
            const walker = document.createTreeWalker(
                doc,
                NodeFilter.SHOW_TEXT,
                null,
                false
            );

            let currentIndex = 0;
            let node;
            let startNode = null;
            let startOffset = 0;
            let endNode = null;
            let endOffset = 0;

            while (node = walker.nextNode()) {
                const nodeLength = node.textContent.length;
                
                // æ‰¾åˆ°å¼€å§‹ä½ç½®
                if (!startNode && currentIndex + nodeLength > startIndex) {
                    startNode = node;
                    startOffset = startIndex - currentIndex;
                }
                
                // æ‰¾åˆ°ç»“æŸä½ç½®
                if (startNode && currentIndex + nodeLength >= startIndex + length) {
                    endNode = node;
                    endOffset = startIndex + length - currentIndex;
                    break;
                }
                
                currentIndex += nodeLength;
            }

            if (startNode && endNode) {
                const range = doc.createRange();
                range.setStart(startNode, startOffset);
                range.setEnd(endNode, endOffset);
                return range;
            }

            return null;
        }

        // æŸ¥æ‰¾å…ƒç´ åœ¨æŒ‡å®šç´¢å¼•ä½ç½®
        function findElementAtIndex(doc, index) {
            const walker = document.createTreeWalker(
                doc,
                NodeFilter.SHOW_TEXT,
                null,
                false
            );

            let currentIndex = 0;
            let node;

            while (node = walker.nextNode()) {
                const nodeLength = node.textContent.length;
                if (currentIndex + nodeLength > index) {
                    return node.parentElement || node.parentNode || doc.body;
                }
                currentIndex += nodeLength;
            }

            return doc.body;
        }

        // æŸ¥æ‰¾æ–‡æœ¬èŠ‚ç‚¹
        function findTextNode(doc, index) {
            const walker = document.createTreeWalker(
                doc,
                NodeFilter.SHOW_TEXT,
                null,
                false
            );

            let currentIndex = 0;
            let node;

            while (node = walker.nextNode()) {
                const nodeLength = node.textContent.length;
                if (currentIndex + nodeLength > index) {
                    return node.parentElement || node;
                }
                currentIndex += nodeLength;
            }

            return doc.body;
        }

        // æŸ¥æ‰¾æŒ‡å®šä½ç½®çš„æ–‡æœ¬èŠ‚ç‚¹
        function findTextNodeAtPosition(doc, index) {
            const walker = document.createTreeWalker(
                doc,
                NodeFilter.SHOW_TEXT,
                null,
                false
            );

            let currentIndex = 0;
            let node;

            while (node = walker.nextNode()) {
                const nodeLength = node.textContent.length;
                if (currentIndex + nodeLength > index) {
                    return node;
                }
                currentIndex += nodeLength;
            }

            return null;
        }

        // éªŒè¯æ–‡æœ¬èŠ‚ç‚¹æ˜¯å¦æœ‰æ•ˆ
        function isValidTextNode(node) {
            if (!node || node.nodeType !== Node.TEXT_NODE) return false;
            
            // æ£€æŸ¥çˆ¶å…ƒç´ æ˜¯å¦åœ¨æœ‰æ•ˆèŒƒå›´å†…
            const parent = node.parentElement;
            if (!parent) return false;
            
            // æ’é™¤è„šæœ¬ã€æ ·å¼ç­‰æ ‡ç­¾
            const invalidTags = ['SCRIPT', 'STYLE', 'NOSCRIPT', 'META', 'LINK'];
            if (invalidTags.includes(parent.tagName)) return false;
            
            // æ£€æŸ¥æ–‡æœ¬å†…å®¹æ˜¯å¦æœ‰æ•ˆ
            const text = node.textContent.trim();
            return text.length > 0;
        }

        // éªŒè¯èŒƒå›´æ˜¯å¦æœ‰æ•ˆ
        function isValidRange(range) {
            if (!range) return false;
            
            try {
                const text = range.toString().trim();
                return text.length > 0 && text.length < 1000; // é¿å…è¿‡é•¿çš„åŒ¹é…
            } catch (error) {
                return false;
            }
        }

        // éªŒè¯å…ƒç´ æ˜¯å¦æœ‰æ•ˆ
        function isValidElement(element) {
            if (!element || element.nodeType !== Node.ELEMENT_NODE) return false;
            
            // æ’é™¤è„šæœ¬ã€æ ·å¼ç­‰æ ‡ç­¾
            const invalidTags = ['SCRIPT', 'STYLE', 'NOSCRIPT', 'META', 'LINK'];
            if (invalidTags.includes(element.tagName)) return false;
            
            return true;
        }

        // è·å–æœç´¢ç»“æœæ‘˜è¦
        function getExcerpt(text, index, length) {
            const start = Math.max(0, index - 20);
            const end = Math.min(text.length, index + length + 20);
            return text.substring(start, end);
        }

        // è·³è½¬åˆ°æœç´¢ç»“æœ
        function goToSearchResult(index) {
            if (index < 0 || index >= searchResults.length) return;

            currentSearchIndex = index;
            const result = searchResults[index];
            
            // è·³è½¬åˆ°å¯¹åº”ä½ç½®
            rendition.display(result.cfi).then(() => {
                // å»¶è¿Ÿä¸€ç‚¹å†é«˜äº®ï¼Œç¡®ä¿é¡µé¢å·²ç»æ¸²æŸ“
                setTimeout(() => {
                    highlightSearchResult();
                }, 150);
            }).catch(error => {
                console.log('CFIè·³è½¬å¤±è´¥:', error);
                // å¦‚æœCFIè·³è½¬å¤±è´¥ï¼Œå°è¯•è·³è½¬åˆ°ç« èŠ‚
                try {
                    const spine = book.spine.get(result.spineIndex);
                    rendition.display(spine.href).then(() => {
                        setTimeout(() => {
                            highlightCurrentPageMatches(result.query);
                        }, 200);
                    });
                } catch (e) {
                    console.log('ç« èŠ‚è·³è½¬ä¹Ÿå¤±è´¥:', e);
                }
            });

            updateSearchInfo();
        }

        // é«˜äº®å½“å‰é¡µé¢çš„åŒ¹é…é¡¹
        function highlightCurrentPageMatches(query) {
            try {
                const views = rendition.views();
                views.forEach(view => {
                    if (view.contents) {
                        const doc = view.contents.document;
                        highlightTextInDocument(doc, query);
                    }
                });
            } catch (error) {
                console.log('é¡µé¢é«˜äº®å¤±è´¥:', error);
            }
        }

        // åœ¨æ–‡æ¡£ä¸­é«˜äº®æ–‡æœ¬
        function highlightTextInDocument(doc, query) {
            if (!doc || !query) return;

            try {
                // ç§»é™¤ä¹‹å‰çš„é«˜äº®
                const existingHighlights = doc.querySelectorAll('.search-highlight-span');
                existingHighlights.forEach(el => {
                    const parent = el.parentNode;
                    if (parent) {
                        parent.replaceChild(doc.createTextNode(el.textContent), el);
                        parent.normalize();
                    }
                });

                // åˆ›å»ºæ–‡æœ¬éå†å™¨
                const walker = doc.createTreeWalker(
                    doc.body,
                    NodeFilter.SHOW_TEXT,
                    {
                        acceptNode: function(node) {
                            // è·³è¿‡å·²ç»åœ¨é«˜äº®spanä¸­çš„æ–‡æœ¬
                            if (node.parentNode && node.parentNode.classList && node.parentNode.classList.contains('search-highlight-span')) {
                                return NodeFilter.FILTER_REJECT;
                            }
                            return NodeFilter.FILTER_ACCEPT;
                        }
                    },
                    false
                );

                const textNodes = [];
                let node;
                while (node = walker.nextNode()) {
                    textNodes.push(node);
                }

                // åœ¨æ¯ä¸ªæ–‡æœ¬èŠ‚ç‚¹ä¸­æœç´¢å¹¶é«˜äº®
                const regex = new RegExp(query.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'gi');
                
                textNodes.forEach(textNode => {
                    const text = textNode.textContent;
                    if (regex.test(text)) {
                        const parent = textNode.parentNode;
                        if (parent && parent.nodeType === Node.ELEMENT_NODE) {
                            const highlightedHTML = text.replace(regex, '<span class="search-highlight-span" style="background-color: #ffeb3b; color: #000; padding: 1px 2px; border-radius: 2px; font-weight: bold;">$&</span>');
                            
                            const tempDiv = doc.createElement('div');
                            tempDiv.innerHTML = highlightedHTML;
                            
                            const fragment = doc.createDocumentFragment();
                            while (tempDiv.firstChild) {
                                fragment.appendChild(tempDiv.firstChild);
                            }
                            
                            parent.replaceChild(fragment, textNode);
                        }
                    }
                });
            } catch (error) {
                console.log('é«˜äº®æ–‡æœ¬å¤±è´¥:', error);
            }
        }

        // é«˜äº®æ˜¾ç¤ºæœç´¢ç»“æœ
        function highlightSearchResult() {
            // æ¸…é™¤ä¹‹å‰çš„é«˜äº®
            if (rendition) {
                try {
                    rendition.annotations.remove('highlight', 'search-highlight');
                } catch (error) {
                    console.log('æ¸…é™¤é«˜äº®å¤±è´¥:', error);
                }
            }
            
            if (currentSearchIndex >= 0 && currentSearchIndex < searchResults.length) {
                const result = searchResults[currentSearchIndex];
                const query = searchInput.value.trim();
                
                if (query) {
                    // ä½¿ç”¨DOMæ“ä½œç›´æ¥é«˜äº®å½“å‰é¡µé¢çš„æ–‡æœ¬
                    highlightCurrentPageMatches(query);
                    
                    // å°è¯•æ»šåŠ¨åˆ°é«˜äº®ä½ç½®
                    setTimeout(() => {
                        scrollToHighlight(query);
                    }, 200);
                }
            }
        }

        // æ»šåŠ¨åˆ°é«˜äº®ä½ç½®
        function scrollToHighlight(query) {
            try {
                const views = rendition.views();
                views.forEach(view => {
                    if (view.contents) {
                        const doc = view.contents.document;
                        const highlights = doc.querySelectorAll('.search-highlight-span');
                        if (highlights.length > 0) {
                            // æ»šåŠ¨åˆ°ç¬¬ä¸€ä¸ªé«˜äº®å…ƒç´ 
                            highlights[0].scrollIntoView({
                                behavior: 'smooth',
                                block: 'center'
                            });
                        }
                    }
                });
            } catch (error) {
                console.log('æ»šåŠ¨åˆ°é«˜äº®ä½ç½®å¤±è´¥:', error);
            }
        }

        // æ¸…é™¤æœç´¢ç»“æœ
        function clearSearchResults() {
            searchResults = [];
            currentSearchIndex = -1;
            
            // æ¸…é™¤epub.jsçš„æ³¨é‡Šé«˜äº®
            if (rendition) {
                try {
                    rendition.annotations.remove('highlight', 'search-highlight');
                } catch (error) {
                    console.log('æ¸…é™¤æ³¨é‡Šé«˜äº®å¤±è´¥:', error);
                }
                
                // æ¸…é™¤è‡ªå®šä¹‰çš„é«˜äº®span
                try {
                    const views = rendition.views();
                    views.forEach(view => {
                        if (view.contents) {
                            const doc = view.contents.document;
                            const highlights = doc.querySelectorAll('.search-highlight-span');
                            highlights.forEach(el => {
                                const parent = el.parentNode;
                                parent.replaceChild(doc.createTextNode(el.textContent), el);
                                parent.normalize();
                            });
                        }
                    });
                } catch (error) {
                    console.log('æ¸…é™¤è‡ªå®šä¹‰é«˜äº®å¤±è´¥:', error);
                }
            }
            
            updateSearchInfo();
        }

        // æ›´æ–°æœç´¢ä¿¡æ¯æ˜¾ç¤º
        function updateSearchInfo() {
            if (searchResults.length === 0) {
                searchInfo.textContent = '';
            } else {
                searchInfo.textContent = `${currentSearchIndex + 1}/${searchResults.length}`;
            }
        }

        // äº‹ä»¶ç›‘å¬
        searchInput.addEventListener('input', (e) => {
            const query = e.target.value;
            if (query.length >= 2 && book) {
                performSearch(query);
            } else {
                clearSearchResults();
            }
        });

        searchInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                if (e.shiftKey) {
                    // Shift+Enter ä¸Šä¸€ä¸ª
                    if (currentSearchIndex > 0) {
                        goToSearchResult(currentSearchIndex - 1);
                    }
                } else {
                    // Enter ä¸‹ä¸€ä¸ª
                    if (currentSearchIndex < searchResults.length - 1) {
                        goToSearchResult(currentSearchIndex + 1);
                    }
                }
            } else if (e.key === 'ArrowUp') {
                e.preventDefault();
                if (currentSearchIndex > 0) {
                    goToSearchResult(currentSearchIndex - 1);
                }
            } else if (e.key === 'ArrowDown') {
                e.preventDefault();
                if (currentSearchIndex < searchResults.length - 1) {
                    goToSearchResult(currentSearchIndex + 1);
                }
            }
        });

        // æ‹–æ‹½ä¸Šä¼ åŠŸèƒ½ï¼ˆä½¿ç”¨ label è§¦å‘ï¼Œæ— éœ€ JSï¼‰

        // æ‹–æ‹½äº‹ä»¶
        uploadArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadContent.classList.add('dragover');
        });

        uploadArea.addEventListener('dragleave', (e) => {
            e.preventDefault();
            uploadContent.classList.remove('dragover');
        });

        uploadArea.addEventListener('drop', async (e) => {
            e.preventDefault();
            uploadContent.classList.remove('dragover');
            
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                const file = files[0];
                if (file.name.endsWith('.epub')) {
                    await loadBook(file);
                } else {
                    alert('è¯·é€‰æ‹© EPUB æ–‡ä»¶');
                }
            }
        });

        // åˆå§‹éšè—å¯¼èˆªæŒ‰é’®
        prevButton.style.display = 'none';
        nextButton.style.display = 'none';

        // ç›®å½•ç›¸å…³å˜é‡
        let toc = null;
        let tocVisible = false;

        // è¿”å›ç›®å½•æŒ‰é’®äº‹ä»¶
        document.getElementById('backHomeBtn').onclick = function() {
            console.log('è¿”å›ç›®å½•æŒ‰é’®è¢«ç‚¹å‡»');
            console.log('book:', book);
            console.log('toc:', toc);
            console.log('tocVisible:', tocVisible);
            
            // å¦‚æœç›®å½•å·²ç»æ˜¾ç¤ºï¼Œåˆ™éšè—ç›®å½•
            if (tocVisible) {
                console.log('ç›®å½•å·²æ˜¾ç¤ºï¼Œéšè—ç›®å½•');
                const tocContainer = document.getElementById('toc-container');
                if (tocContainer) {
                    tocContainer.remove();
                    tocVisible = false;
                }
                this.classList.remove('active');
                return;
            }
            
            // å¦‚æœç›®å½•æœªæ˜¾ç¤ºï¼Œåˆ™æ˜¾ç¤ºç›®å½•
            if (book && toc) {
                console.log('æ˜¾ç¤ºå·²åŠ è½½çš„ç›®å½•');
                showTableOfContents();
                this.classList.add('active');
            } else if (book) {
                console.log('åŠ è½½ç›®å½•ä¸­...');
                loadTableOfContents();
                this.classList.add('active');
            } else {
                alert('è¯·å…ˆæ‰“å¼€ä¸€æœ¬ç”µå­ä¹¦');
            }
        };

        // åŠ è½½ç›®å½•
        async function loadTableOfContents() {
            try {
                console.log('å¼€å§‹åŠ è½½ç›®å½•...');
                
                // å°è¯•å¤šç§æ–¹å¼è·å–ç›®å½•
                if (book.loaded && book.loaded.navigation) {
                    toc = await book.loaded.navigation;
                } else if (book.navigation) {
                    toc = await book.navigation;
                } else if (book.toc) {
                    toc = await book.toc;
                } else {
                    // å°è¯•ç›´æ¥è·å–ç›®å½•
                    toc = await book.ready;
                    if (toc && toc.navigation) {
                        toc = toc.navigation;
                    }
                }
                
                console.log('ç›®å½•åŠ è½½æˆåŠŸ:', toc);
                showTableOfContents();
            } catch (error) {
                console.error('åŠ è½½ç›®å½•å¤±è´¥:', error);
                // å°è¯•å¤‡ç”¨æ–¹æ³•
                try {
                    console.log('å°è¯•å¤‡ç”¨æ–¹æ³•è·å–ç›®å½•...');
                    if (book.spine) {
                        // ä»spineç”Ÿæˆç®€å•çš„ç›®å½•
                        const spineItems = book.spine.items;
                        toc = {
                            toc: spineItems.map((item, index) => ({
                                label: item.title || `ç¬¬${index + 1}ç« `,
                                href: item.href,
                                subitems: []
                            }))
                        };
                        console.log('ä»spineç”Ÿæˆç›®å½•æˆåŠŸ:', toc);
                        showTableOfContents();
                    } else {
                        alert('è¯¥ç”µå­ä¹¦æ²¡æœ‰ç›®å½•');
                    }
                } catch (backupError) {
                    console.error('å¤‡ç”¨æ–¹æ³•ä¹Ÿå¤±è´¥:', backupError);
                    alert('æ— æ³•åŠ è½½ç›®å½•');
                }
            }
        }

        // æ˜¾ç¤ºç›®å½•
        function showTableOfContents() {
            console.log('æ˜¾ç¤ºç›®å½•å‡½æ•°è¢«è°ƒç”¨');
            console.log('toc:', toc);
            
            if (!toc || !toc.toc) {
                console.log('æ²¡æœ‰æ‰¾åˆ°ç›®å½•æ•°æ®');
                alert('è¯¥ç”µå­ä¹¦æ²¡æœ‰ç›®å½•');
                return;
            }

            // åˆ›å»ºç›®å½•HTML
            let tocHtml = '<div style="padding: 20px; height: 100%; overflow-y: auto; background: white; font-family: -apple-system, BlinkMacSystemFont, sans-serif;">';
            
            // æ·»åŠ ä¹¦å
            if (book && book.package && book.package.metadata) {
                const title = book.package.metadata.title || 'æœªçŸ¥ä¹¦å';
                tocHtml += '<h3 style="margin-bottom: 20px; color: #333; font-size: 16px; font-weight: 600; border-bottom: 1px solid #e0e0e0; padding-bottom: 10px;">' + title + '</h3>';
            }
            
            function buildTocList(items, level = 0) {
                let html = '<ul style="list-style: none; padding-left: ' + (level * 15) + 'px; margin: 0;">';
                items.forEach(item => {
                    html += '<li style="margin: 6px 0;">';
                    const hoverStyle = 'this.style.background="#f5f5f5"; this.style.borderColor="#1976d2"';
                    const outStyle = 'this.style.background="transparent"; this.style.borderColor="transparent"';
                    html += '<a href="#" data-href="' + item.href + '" style="color: #1976d2; text-decoration: none; display: block; padding: 10px 12px; border-radius: 6px; transition: all 0.2s; font-size: 14px; border: 1px solid transparent;" onmouseover="' + hoverStyle + '" onmouseout="' + outStyle + '">';
                    html += item.label;
                    html += '</a>';
                    if (item.subitems && item.subitems.length > 0) {
                        html += buildTocList(item.subitems, level + 1);
                    }
                    html += '</li>';
                });
                html += '</ul>';
                return html;
            }
            
            tocHtml += buildTocList(toc.toc);
            tocHtml += '</div>';

            // ä½¿ç”¨ç‰¹æ®Šæ–¹æ³•æ˜¾ç¤ºç›®å½•
            console.log('å‡†å¤‡æ˜¾ç¤ºç›®å½•HTML:', tocHtml);
            
            // åˆ›å»ºå·¦ä¾§ç›®å½•é¢æ¿
            const viewer = document.getElementById('viewer');
            const tempDiv = document.createElement('div');
            tempDiv.id = 'toc-container';
            tempDiv.innerHTML = tocHtml;
            tempDiv.style.cssText = 'position: absolute; top: 0; left: 0; width: 300px; height: 100%; background: white; z-index: 1000; overflow-y: auto; border-right: 1px solid #e0e0e0; box-shadow: 2px 0 8px rgba(0,0,0,0.1);';
            
            viewer.appendChild(tempDiv);
            tocVisible = true;
            console.log('ç›®å½•æ˜¾ç¤ºå®Œæˆ');

            // æ·»åŠ ç›®å½•é¡¹ç‚¹å‡»äº‹ä»¶
            setTimeout(() => {
                const tocLinks = tempDiv.querySelectorAll('[data-href]');
                tocLinks.forEach(link => {
                    link.addEventListener('click', (e) => {
                        e.preventDefault();
                        const href = link.getAttribute('data-href');
                        if (href) {
                            // ç§»é™¤ç›®å½•æ˜¾ç¤º
                            viewer.removeChild(tempDiv);
                            tocVisible = false;
                            // ç§»é™¤ç›®å½•æŒ‰é’®çš„å‡¹é™·æ•ˆæœ
                            const backHomeBtn = document.getElementById('backHomeBtn');
                            if (backHomeBtn) {
                                backHomeBtn.classList.remove('active');
                            }
                            // è·³è½¬åˆ°æŒ‡å®šä½ç½®
                            rendition.display(href);
                        }
                    });
                });
            }, 100);

            // æ·»åŠ ç‚¹å‡»ç›®å½•å¤–åŒºåŸŸå…³é—­ç›®å½•çš„åŠŸèƒ½
            function closeTocOnOutsideClick(e) {
                // å¦‚æœç‚¹å‡»çš„æ˜¯ç›®å½•å†…éƒ¨æˆ–æŒ‰é’®ï¼Œä¸å…³é—­
                const isInsideToc = tempDiv.contains(e.target);
                const isBtn = e.target.closest && e.target.closest('#backHomeBtn');
                
                if (tocVisible && !isInsideToc && !isBtn) {
                    // ç§»é™¤ç›®å½•
                    if (tempDiv.parentNode) {
                        tempDiv.parentNode.removeChild(tempDiv);
                    }
                    tocVisible = false;
                    
                    // ç§»é™¤ç›®å½•æŒ‰é’®çš„å‡¹é™·æ•ˆæœ
                    const backHomeBtn = document.getElementById('backHomeBtn');
                    if (backHomeBtn) {
                        backHomeBtn.classList.remove('active');
                    }
                    
                    // ç§»é™¤ç›‘å¬å™¨
                    document.removeEventListener('click', closeTocOnOutsideClick);
                    const frames = viewer.querySelectorAll('iframe');
                    frames.forEach(iframe => {
                        try {
                            iframe.contentDocument.removeEventListener('click', closeTocOnOutsideClick);
                        } catch(e) {}
                    });
                }
            }
            
            // å»¶è¿Ÿæ·»åŠ äº‹ä»¶ç›‘å¬å™¨ï¼Œé¿å…ç«‹å³è§¦å‘
            setTimeout(() => {
                document.addEventListener('click', closeTocOnOutsideClick);
                
                // åŒæ—¶ç»™ iframe å†…éƒ¨æ·»åŠ ç‚¹å‡»ç›‘å¬ï¼Œä»¥ä¾¿ç‚¹å‡»é˜…è¯»å™¨å†…å®¹æ—¶ä¹Ÿèƒ½å…³é—­ç›®å½•
                const frames = viewer.querySelectorAll('iframe');
                frames.forEach(iframe => {
                    try {
                        iframe.contentDocument.addEventListener('click', closeTocOnOutsideClick);
                    } catch(e) {
                        console.warn('æ— æ³•ç»‘å®šiframeç‚¹å‡»äº‹ä»¶', e);
                    }
                });
            }, 100);
        }

        // ========== ç¬”è®°é¢æ¿åŠŸèƒ½ ==========
        let notesVisible = false;

        // è·å–å½“å‰ä¹¦ç±ID
        function getCurrentBookId() {
            try {
                if (book && book.package && book.package.metadata) {
                    const title = book.package.metadata.title || 'æœªçŸ¥ä¹¦å';
                    let hash = 0;
                    for (let i = 0; i < title.length; i++) {
                        const char = title.charCodeAt(i);
                        hash = ((hash << 5) - hash) + char;
                        hash = hash & hash;
                    }
                    return 'book_' + Math.abs(hash).toString(16);
                }
            } catch (e) {
                console.warn('è·å–ä¹¦ç±IDå¤±è´¥:', e);
            }
            return null;
        }

        // è·å–å½“å‰ä¹¦ç±çš„ç¬”è®°
        function getNotesForCurrentBook() {
            const bookId = getCurrentBookId();
            try {
                const notes = JSON.parse(localStorage.getItem('book-notes') || '[]');
                if (bookId) {
                    return notes.filter(n => n.bookId === bookId);
                }
                return notes;
            } catch (e) {
                console.error('è·å–ç¬”è®°å¤±è´¥:', e);
                return [];
            }
        }

        // åˆ é™¤ç¬”è®°
        function deleteNote(noteId) {
            try {
                let notes = JSON.parse(localStorage.getItem('book-notes') || '[]');
                notes = notes.filter(n => n.id !== noteId);
                localStorage.setItem('book-notes', JSON.stringify(notes));
                return true;
            } catch (e) {
                console.error('åˆ é™¤ç¬”è®°å¤±è´¥:', e);
                return false;
            }
        }

        // æ›´æ–°ç¬”è®°å†…å®¹ï¼ˆå†…è”ç¼–è¾‘ï¼‰
        function updateNoteContent(noteId, newContent) {
            try {
                let notes = JSON.parse(localStorage.getItem('book-notes') || '[]');
                const noteIndex = notes.findIndex(n => n.id === noteId);
                if (noteIndex !== -1) {
                    const oldContent = notes[noteIndex].note;
                    if (oldContent !== newContent) {
                        notes[noteIndex].note = newContent;
                        notes[noteIndex].updated = new Date().toISOString();
                        localStorage.setItem('book-notes', JSON.stringify(notes));
                        console.log('âœ… ç¬”è®°å·²æ›´æ–°:', noteId);
                        
                        // æ˜¾ç¤ºä¿å­˜æç¤º
                        const toast = document.createElement('div');
                        toast.style.cssText = 'position:fixed;bottom:40px;left:50%;transform:translateX(-50%);background:rgba(0,0,0,0.85);color:white;padding:12px 24px;border-radius:24px;font-size:14px;z-index:1000000;font-weight:500;box-shadow:0 4px 12px rgba(0,0,0,0.3);';
                        toast.textContent = 'âœ… ç¬”è®°å·²ä¿å­˜';
                        document.body.appendChild(toast);
                        setTimeout(() => toast.remove(), 1500);
                    }
                    return true;
                }
                return false;
            } catch (e) {
                console.error('æ›´æ–°ç¬”è®°å¤±è´¥:', e);
                return false;
            }
        }

        // æ ¼å¼åŒ–æ—¶é—´
        function formatNoteTime(isoString) {
            const date = new Date(isoString);
            const now = new Date();
            const diff = now - date;
            
            if (diff < 60000) return 'åˆšåˆš';
            if (diff < 3600000) return Math.floor(diff / 60000) + 'åˆ†é’Ÿå‰';
            if (diff < 86400000) return Math.floor(diff / 3600000) + 'å°æ—¶å‰';
            if (diff < 604800000) return Math.floor(diff / 86400000) + 'å¤©å‰';
            
            return date.toLocaleDateString('zh-CN', { month: 'short', day: 'numeric' });
        }

        // å¯¼å‡ºå½“å‰ä¹¦ç±çš„æ‰€æœ‰ç¬”è®°
        function exportNotesForCurrentBook() {
            const bookId = getCurrentBookId();
            const notes = getNotesForCurrentBook();
            if (!notes || notes.length === 0) {
                alert('å½“å‰è¿™æœ¬ä¹¦è¿˜æ²¡æœ‰ç¬”è®°å¯ä»¥å¯¼å‡º');
                return;
            }

            let bookTitle = 'book';
            try {
                if (book && book.package && book.package.metadata && book.package.metadata.title) {
                    bookTitle = book.package.metadata.title;
                }
            } catch (e) {}

            const payload = {
                type: 'tobooks-notes',
                version: 1,
                bookId: bookId,
                bookTitle: bookTitle,
                exportedAt: new Date().toISOString(),
                notes: notes
            };

            const blob = new Blob([JSON.stringify(payload, null, 2)], { type: 'application/json' });

            const safeTitle = (bookTitle || 'book')
                .replace(/[\\/:*?"<>|]/g, '_')
                .slice(0, 40);

            const fileName = `${safeTitle || 'book'}-notes-${new Date().toISOString().slice(0,10)}.json`;

            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = fileName;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(link.href);
        }

        // ä» JSON æ–‡ä»¶å¯¼å…¥ç¬”è®°
        function importNotesFromFile(file) {
            if (!file) return;

            if (!file.name.endsWith('.json')) {
                alert('è¯·é€‰æ‹© JSON æ ¼å¼çš„ç¬”è®°æ–‡ä»¶');
                return;
            }

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const data = JSON.parse(e.target.result);

                    if (!data || !Array.isArray(data.notes)) {
                        alert('ç¬”è®°æ–‡ä»¶æ ¼å¼ä¸æ­£ç¡®');
                        return;
                    }

                    const currentBookId = getCurrentBookId();
                    if (data.bookId && currentBookId && data.bookId !== currentBookId) {
                        const ok = confirm('è¿™ä¸ªç¬”è®°æ–‡ä»¶çœ‹èµ·æ¥æ¥è‡ªå¦ä¸€æœ¬ä¹¦ï¼Œä»ç„¶å¯¼å…¥åˆ°å½“å‰è¿™æœ¬ä¹¦å—ï¼Ÿ');
                        if (!ok) return;
                    }

                    let allNotes = [];
                    try {
                        allNotes = JSON.parse(localStorage.getItem('book-notes') || '[]');
                    } catch (err) {
                        allNotes = [];
                    }

                    const targetBookId = currentBookId || data.bookId || null;
                    const existingKeys = new Set(
                        allNotes
                            .filter(n => n.bookId === targetBookId)
                            .map(n => `${n.cfi}::${n.note}`)
                    );

                    let importedCount = 0;
                    const nowTs = Date.now();

                    data.notes.forEach((n, index) => {
                        if (!n || !n.cfi) return;

                        const key = `${n.cfi}::${n.note || ''}`;
                        if (existingKeys.has(key)) return;

                        const newNote = {
                            id: 'note_' + (nowTs + index),
                            bookId: targetBookId,
                            cfi: n.cfi,
                            text: n.text || '',
                            note: n.note || '',
                            created: n.created || new Date().toISOString()
                        };

                        allNotes.push(newNote);
                        existingKeys.add(key);
                        importedCount++;

                        // ä¸ºå¯¼å…¥çš„ç¬”è®°æ·»åŠ é«˜äº®ï¼Œæ–¹ä¾¿è§†è§‰å®šä½
                        try {
                            if (rendition && window.highlightManager) {
                                rendition.annotations.add(
                                    'highlight',
                                    newNote.cfi,
                                    { color: 'yellow', hasNote: true },
                                    null,
                                    'highlight-yellow',
                                    { 'fill': '#FFD54F', 'fill-opacity': '0.3' }
                                );
                            }

                            let highlights = [];
                            try {
                                highlights = JSON.parse(localStorage.getItem('book-highlights') || '[]');
                            } catch (err) {
                                highlights = [];
                            }
                            if (!highlights.find(h => h.cfi === newNote.cfi)) {
                                highlights.push({
                                    cfi: newNote.cfi,
                                    colorId: 'yellow',
                                    hasNote: true,
                                    created: new Date().toISOString()
                                });
                                localStorage.setItem('book-highlights', JSON.stringify(highlights));
                            }
                        } catch (err) {
                            console.warn('å¯¼å…¥ç¬”è®°æ—¶æ·»åŠ é«˜äº®å¤±è´¥:', err);
                        }
                    });

                    localStorage.setItem('book-notes', JSON.stringify(allNotes));

                    if (importedCount === 0) {
                        alert('æ²¡æœ‰æ–°çš„ç¬”è®°éœ€è¦å¯¼å…¥ï¼ˆå¯èƒ½éƒ½å·²å­˜åœ¨ï¼‰');
                    } else {
                        alert(`å·²å¯¼å…¥ ${importedCount} æ¡ç¬”è®°`);
                    }

                    if (notesVisible) {
                        hideNotesPanel();
                        showNotesPanel();
                    }
                } catch (err) {
                    console.error('å¯¼å…¥ç¬”è®°å¤±è´¥', err);
                    alert('å¯¼å…¥å¤±è´¥ï¼šæ–‡ä»¶æ ¼å¼æˆ–å†…å®¹ä¸æ­£ç¡®');
                }
            };

            reader.onerror = function() {
                alert('è¯»å–æ–‡ä»¶å¤±è´¥ï¼Œè¯·é‡è¯•');
            };

            reader.readAsText(file, 'utf-8');
        }

        // å½“å‰æ­£åœ¨ç¼–è¾‘çš„ç¬”è®°æ•°æ®
        let pendingNoteData = null;

        // æ˜¾ç¤ºç¬”è®°é¢æ¿
        function showNotesPanel(editData = null) {
            console.log('æ˜¾ç¤ºç¬”è®°é¢æ¿', editData ? '(ç¼–è¾‘æ¨¡å¼)' : '');
            
            // ä¿å­˜å¾…ç¼–è¾‘çš„æ•°æ®
            pendingNoteData = editData;
            
            const viewer = document.getElementById('viewer');
            const notes = getNotesForCurrentBook();
            
            // åˆ›å»ºç¬”è®°é¢æ¿HTML
            let notesHtml = `
                <div class="notes-header">
                    <h3>ğŸ“ æˆ‘çš„ç¬”è®° (${notes.length})</h3>
                    <div class="notes-header-actions">
                        <button class="notes-action-btn" id="notes-export-btn">å¯¼å‡º</button>
                        <button class="notes-action-btn" id="notes-import-btn">å¯¼å…¥</button>
                        <input type="file" id="notes-import-file" accept="application/json" style="display:none" />
                        <button class="notes-close-btn" id="notes-close-btn">Ã—</button>
                    </div>
                </div>
                <div class="notes-list">
            `;
            
            // å¦‚æœæ˜¯ç¼–è¾‘æ¨¡å¼ï¼Œæ˜¾ç¤ºç¼–è¾‘åŒºåŸŸ
            if (editData) {
                const shortText = editData.text.length > 100 ? editData.text.substring(0, 100) + '...' : editData.text;
                // è·å–å·²æœ‰é«˜äº®çš„é¢œè‰²ï¼Œé»˜è®¤ä¸ºé»„è‰²
                const selectedColor = editData.colorId || 'yellow';
                notesHtml += `
                    <div class="note-editor" id="note-editor">
                        <div class="note-editor-label">ğŸ“ é€‰ä¸­çš„æ–‡æœ¬ï¼š</div>
                        <div class="note-editor-highlight">"${shortText}"</div>
                        <div class="note-color-picker">
                            <span class="note-color-picker-label">ğŸ¨ é«˜äº®é¢œè‰²ï¼š</span>
                            <div class="note-color-options">
                                <div class="note-color-btn ${selectedColor === 'yellow' ? 'selected' : ''}" data-color-id="yellow" data-color="#FFD54F" data-class="highlight-yellow" style="background:#FFD54F" title="é»„è‰²"></div>
                                <div class="note-color-btn ${selectedColor === 'green' ? 'selected' : ''}" data-color-id="green" data-color="#81C784" data-class="highlight-green" style="background:#81C784" title="ç»¿è‰²"></div>
                                <div class="note-color-btn ${selectedColor === 'blue' ? 'selected' : ''}" data-color-id="blue" data-color="#64B5F6" data-class="highlight-blue" style="background:#64B5F6" title="è“è‰²"></div>
                                <div class="note-color-btn ${selectedColor === 'pink' ? 'selected' : ''}" data-color-id="pink" data-color="#F06292" data-class="highlight-pink" style="background:#F06292" title="ç²‰è‰²"></div>
                                <div class="note-color-btn ${selectedColor === 'purple' ? 'selected' : ''}" data-color-id="purple" data-color="#CE93D8" data-class="highlight-purple" style="background:#CE93D8" title="ç´«è‰²"></div>
                            </div>
                        </div>
                        <div class="note-editor-label">âœï¸ å†™ä¸‹ä½ çš„ç¬”è®°ï¼š</div>
                        <textarea class="note-editor-textarea" id="note-editor-textarea" placeholder="åœ¨è¿™é‡Œè¾“å…¥ä½ çš„ç¬”è®°..." autofocus></textarea>
                        <div class="note-editor-actions">
                            <button class="note-editor-btn cancel" id="note-editor-cancel">å–æ¶ˆ</button>
                            <button class="note-editor-btn save" id="note-editor-save">ä¿å­˜ç¬”è®°</button>
                        </div>
                    </div>
                `;
            }
            
            if (notes.length === 0 && !editData) {
                notesHtml += `
                    <div class="notes-empty">
                        <div class="notes-empty-icon">ğŸ“</div>
                        <p>è¿˜æ²¡æœ‰ç¬”è®°</p>
                        <p style="font-size: 12px; margin-top: 8px;">é€‰ä¸­æ–‡æœ¬åç‚¹å‡»"æ·»åŠ ç¬”è®°"æ¥åˆ›å»º</p>
                    </div>
                `;
            } else if (notes.length > 0) {
                // æŒ‰æ—¶é—´å€’åºæ’åˆ—
                notes.sort((a, b) => new Date(b.created) - new Date(a.created));
                
                notes.forEach(note => {
                    const shortText = note.text.length > 80 ? note.text.substring(0, 80) + '...' : note.text;
                    notesHtml += `
                        <div class="note-item" data-cfi="${note.cfi}" data-note-id="${note.id}">
                            <button class="note-delete-btn" data-delete-id="${note.id}" title="åˆ é™¤ç¬”è®°">ğŸ—‘ï¸</button>
                            <div class="note-text">"${shortText}"</div>
                            <div class="note-content" contenteditable="true" data-note-id="${note.id}">${note.note}</div>
                            <div class="note-time">${formatNoteTime(note.created)}</div>
                        </div>
                    `;
                });
            }
            
            notesHtml += '</div>';
            
            // åˆ›å»ºç¬”è®°é¢æ¿å®¹å™¨
            const notesContainer = document.createElement('div');
            notesContainer.id = 'notes-container';
            notesContainer.innerHTML = notesHtml;
            
            viewer.appendChild(notesContainer);
            notesVisible = true;
            console.log('ç¬”è®°é¢æ¿æ˜¾ç¤ºå®Œæˆï¼Œå…±', notes.length, 'æ¡ç¬”è®°');
            
            // ç»‘å®šå…³é—­æŒ‰é’®äº‹ä»¶
            document.getElementById('notes-close-btn').addEventListener('click', hideNotesPanel);

            // ç»‘å®šå¯¼å‡º / å¯¼å…¥æŒ‰é’®äº‹ä»¶
            const exportBtn = document.getElementById('notes-export-btn');
            const importBtn = document.getElementById('notes-import-btn');
            const importFileInput = document.getElementById('notes-import-file');

            if (exportBtn) {
                exportBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    exportNotesForCurrentBook();
                });
            }

            if (importBtn && importFileInput) {
                importBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    importFileInput.click();
                });

                importFileInput.addEventListener('change', () => {
                    if (importFileInput.files && importFileInput.files[0]) {
                        importNotesFromFile(importFileInput.files[0]);
                        importFileInput.value = '';
                    }
                });
            }
            
            // ç»‘å®šç¬”è®°é¡¹ç‚¹å‡»äº‹ä»¶ï¼ˆè·³è½¬åˆ°å¯¹åº”ä½ç½®ï¼‰
            setTimeout(() => {
                const noteItems = notesContainer.querySelectorAll('.note-item');
                noteItems.forEach(item => {
                    item.addEventListener('click', (e) => {
                        // å¦‚æœç‚¹å‡»çš„æ˜¯åˆ é™¤æŒ‰é’®æˆ–ç¬”è®°å†…å®¹ï¼Œä¸è·³è½¬
                        if (e.target.classList.contains('note-delete-btn') || 
                            e.target.classList.contains('note-content')) {
                            return;
                        }
                        
                        const cfi = item.getAttribute('data-cfi');
                        if (cfi && rendition) {
                            console.log('è·³è½¬åˆ°ç¬”è®°ä½ç½®:', cfi);
                            hideNotesPanel();
                            
                            // è·³è½¬åˆ°ç¬”è®°ä½ç½®ï¼Œå¹¶åœ¨è·³è½¬å®Œæˆåæ˜¾ç¤ºä¸´æ—¶é«˜äº®
                            rendition.display(cfi).then(() => {
                                // å»¶è¿Ÿä¸€ç‚¹ç¡®ä¿é¡µé¢æ¸²æŸ“å®Œæˆ
                                setTimeout(() => {
                                    if (window.highlightManager) {
                                        window.highlightManager.showTemporaryHighlight(cfi, 2500);
                                    }
                                }, 300);
                            });
                        }
                    });
                });
                
                // ç»‘å®šç¬”è®°å†…å®¹å†…è”ç¼–è¾‘äº‹ä»¶
                const noteContents = notesContainer.querySelectorAll('.note-content[contenteditable]');
                noteContents.forEach(content => {
                    // ç‚¹å‡»æ—¶é˜»æ­¢å†’æ³¡
                    content.addEventListener('click', (e) => {
                        e.stopPropagation();
                    });
                    
                    // è·å¾—ç„¦ç‚¹æ—¶æ·»åŠ ç¼–è¾‘çŠ¶æ€
                    content.addEventListener('focus', (e) => {
                        content.classList.add('editing');
                    });
                    
                    // å¤±å»ç„¦ç‚¹æ—¶ä¿å­˜
                    content.addEventListener('blur', (e) => {
                        content.classList.remove('editing');
                        const noteId = content.getAttribute('data-note-id');
                        const newText = content.innerText.trim();
                        
                        if (noteId && newText) {
                            updateNoteContent(noteId, newText);
                        }
                    });
                    
                    // æŒ‰Cmd+Enterä¿å­˜å¹¶å¤±å»ç„¦ç‚¹
                    content.addEventListener('keydown', (e) => {
                        if (e.key === 'Enter' && e.metaKey) {
                            e.preventDefault();
                            content.blur();
                        }
                        // æŒ‰Escapeå–æ¶ˆç¼–è¾‘
                        if (e.key === 'Escape') {
                            // æ¢å¤åŸå§‹å†…å®¹
                            const noteId = content.getAttribute('data-note-id');
                            const notes = JSON.parse(localStorage.getItem('book-notes') || '[]');
                            const note = notes.find(n => n.id === noteId);
                            if (note) {
                                content.innerText = note.note;
                            }
                            content.blur();
                        }
                    });
                });
                
                // ç»‘å®šåˆ é™¤æŒ‰é’®äº‹ä»¶
                const deleteButtons = notesContainer.querySelectorAll('.note-delete-btn');
                deleteButtons.forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        const noteId = btn.getAttribute('data-delete-id');
                        if (noteId && confirm('ç¡®å®šè¦åˆ é™¤è¿™æ¡ç¬”è®°å—ï¼Ÿ')) {
                            deleteNote(noteId);
                            // åˆ·æ–°ç¬”è®°é¢æ¿
                            hideNotesPanel();
                            showNotesPanel();
                        }
                    });
                });
                
                // ç»‘å®šç¼–è¾‘å™¨æŒ‰é’®äº‹ä»¶
                const saveBtn = document.getElementById('note-editor-save');
                const cancelBtn = document.getElementById('note-editor-cancel');
                const textarea = document.getElementById('note-editor-textarea');
                
                if (saveBtn && pendingNoteData) {
                    saveBtn.addEventListener('click', () => {
                        const noteContent = textarea.value.trim();
                        if (!noteContent) {
                            alert('è¯·è¾“å…¥ç¬”è®°å†…å®¹');
                            textarea.focus();
                            return;
                        }
                        
                        // ä¿å­˜ç¬”è®°
                        const bookId = getCurrentBookId();
                        const noteData = {
                            id: 'note_' + Date.now(),
                            bookId: bookId,
                            cfi: pendingNoteData.cfi,
                            text: pendingNoteData.text,
                            note: noteContent,
                            created: new Date().toISOString()
                        };
                        
                        let notes = JSON.parse(localStorage.getItem('book-notes') || '[]');
                        notes.push(noteData);
                        localStorage.setItem('book-notes', JSON.stringify(notes));
                        
                        // è·å–é€‰ä¸­çš„é¢œè‰²
                        const selectedColorBtn = document.querySelector('.note-color-btn.selected');
                        const colorId = selectedColorBtn ? selectedColorBtn.getAttribute('data-color-id') : 'yellow';
                        const colorValue = selectedColorBtn ? selectedColorBtn.getAttribute('data-color') : '#FFD54F';
                        const colorClass = selectedColorBtn ? selectedColorBtn.getAttribute('data-class') : 'highlight-yellow';
                        
                        // æ·»åŠ æˆ–æ›´æ–°é«˜äº®æ ‡è®°
                        if (rendition && pendingNoteData.cfi) {
                            // æ£€æŸ¥é«˜äº®æ˜¯å¦å·²å­˜åœ¨
                            let highlights = JSON.parse(localStorage.getItem('book-highlights') || '[]');
                            const existingHighlightIndex = highlights.findIndex(h => h.cfi === pendingNoteData.cfi);
                            
                            if (existingHighlightIndex !== -1) {
                                // é«˜äº®å·²å­˜åœ¨ï¼Œåªæ›´æ–° hasNote å±æ€§
                                highlights[existingHighlightIndex].hasNote = true;
                                localStorage.setItem('book-highlights', JSON.stringify(highlights));
                                console.log('âœ… å·²æ›´æ–°ç°æœ‰é«˜äº®çš„ç¬”è®°çŠ¶æ€');
                            } else {
                                // é«˜äº®ä¸å­˜åœ¨ï¼Œæ·»åŠ æ–°é«˜äº®
                                rendition.annotations.add(
                                    'highlight', 
                                    pendingNoteData.cfi, 
                                    { color: colorId, hasNote: true }, 
                                    null,
                                    colorClass,
                                    { 'fill': colorValue, 'fill-opacity': '0.3' }
                                );
                                
                                highlights.push({
                                    cfi: pendingNoteData.cfi,
                                    colorId: colorId,
                                    hasNote: true,
                                    created: new Date().toISOString()
                                });
                                localStorage.setItem('book-highlights', JSON.stringify(highlights));
                            }
                        }
                        
                        console.log('âœ… ç¬”è®°å·²ä¿å­˜:', noteData);
                        
                        // æ˜¾ç¤ºä¿å­˜æˆåŠŸæç¤º
                        const toast = document.createElement('div');
                        toast.style.cssText = 'position:fixed;bottom:40px;left:50%;transform:translateX(-50%);background:rgba(0,0,0,0.85);color:white;padding:12px 24px;border-radius:24px;font-size:14px;z-index:1000000;font-weight:500;box-shadow:0 4px 12px rgba(0,0,0,0.3);';
                        toast.textContent = 'âœ… ç¬”è®°å·²ä¿å­˜';
                        document.body.appendChild(toast);
                        setTimeout(() => toast.remove(), 2000);
                        
                        // æ¸…é™¤å¾…ç¼–è¾‘æ•°æ®å¹¶åˆ·æ–°é¢æ¿
                        pendingNoteData = null;
                        hideNotesPanel();
                        showNotesPanel();
                        
                        // æ´¾å‘ç¬”è®°æ·»åŠ äº‹ä»¶
                        window.dispatchEvent(new CustomEvent('noteAdded', { detail: noteData }));
                    });
                }
                
                if (cancelBtn) {
                    cancelBtn.addEventListener('click', () => {
                        pendingNoteData = null;
                        hideNotesPanel();
                        showNotesPanel();
                    });
                }
                
                // ç»‘å®šé¢œè‰²é€‰æ‹©æŒ‰é’®äº‹ä»¶
                const colorBtns = notesContainer.querySelectorAll('.note-color-btn');
                colorBtns.forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        // ç§»é™¤å…¶ä»–æŒ‰é’®çš„é€‰ä¸­çŠ¶æ€
                        colorBtns.forEach(b => b.classList.remove('selected'));
                        // é€‰ä¸­å½“å‰æŒ‰é’®
                        btn.classList.add('selected');
                    });
                });
                
                // è‡ªåŠ¨èšç„¦åˆ°æ–‡æœ¬æ¡†ï¼Œå¹¶æ·»åŠ  Enter é”®ä¿å­˜åŠŸèƒ½
                if (textarea && editData) {
                    textarea.focus();
                    
                    // æŒ‰ Cmd+Enter ç›´æ¥ä¿å­˜
                    textarea.addEventListener('keydown', (e) => {
                        if (e.key === 'Enter' && e.metaKey) {
                            e.preventDefault();
                            // è§¦å‘ä¿å­˜æŒ‰é’®ç‚¹å‡»
                            if (saveBtn) {
                                saveBtn.click();
                            }
                        }
                    });
                }
            }, 100);
            
            // ç‚¹å‡»é¢æ¿å¤–åŒºåŸŸå…³é—­
            function closeNotesOnOutsideClick(e) {
                const isInsideNotes = notesContainer.contains(e.target);
                const isNotesBtn = e.target.closest && e.target.closest('#notes-btn');
                
                if (notesVisible && !isInsideNotes && !isNotesBtn) {
                    hideNotesPanel();
                    document.removeEventListener('click', closeNotesOnOutsideClick);
                    
                    const frames = viewer.querySelectorAll('iframe');
                    frames.forEach(iframe => {
                        try {
                            iframe.contentDocument.removeEventListener('click', closeNotesOnOutsideClick);
                        } catch(e) {}
                    });
                }
            }
            
            setTimeout(() => {
                document.addEventListener('click', closeNotesOnOutsideClick);
                
                const frames = viewer.querySelectorAll('iframe');
                frames.forEach(iframe => {
                    try {
                        iframe.contentDocument.addEventListener('click', closeNotesOnOutsideClick);
                    } catch(e) {
                        console.warn('æ— æ³•ç»‘å®šiframeç‚¹å‡»äº‹ä»¶', e);
                    }
                });
            }, 100);
        }

        // éšè—ç¬”è®°é¢æ¿
        function hideNotesPanel() {
            const notesContainer = document.getElementById('notes-container');
            if (notesContainer) {
                notesContainer.remove();
                notesVisible = false;
                console.log('ç¬”è®°é¢æ¿å·²éšè—');
            }
            // ç§»é™¤ç¬”è®°æŒ‰é’®çš„å‡¹é™·æ•ˆæœ
            const notesBtn = document.getElementById('notes-btn');
            if (notesBtn) {
                notesBtn.classList.remove('active');
            }
        }

        // ç¬”è®°æŒ‰é’®ç‚¹å‡»äº‹ä»¶
        document.getElementById('notes-btn').addEventListener('click', function() {
            console.log('ç¬”è®°æŒ‰é’®è¢«ç‚¹å‡»');
            
            if (notesVisible) {
                hideNotesPanel();
                return;
            }
            
            if (!book) {
                alert('è¯·å…ˆæ‰“å¼€ä¸€æœ¬ç”µå­ä¹¦');
                return;
            }
            
            showNotesPanel();
            // æ·»åŠ ç¬”è®°æŒ‰é’®çš„å‡¹é™·æ•ˆæœ
            this.classList.add('active');
        });

        // ç›‘å¬ç¬”è®°æ·»åŠ äº‹ä»¶ï¼Œè‡ªåŠ¨åˆ·æ–°é¢æ¿
        window.addEventListener('noteAdded', function(e) {
            console.log('æ”¶åˆ°ç¬”è®°æ·»åŠ äº‹ä»¶:', e.detail);
            if (notesVisible) {
                hideNotesPanel();
                showNotesPanel();
            }
        });

        // ç›‘å¬æ‰“å¼€ç¬”è®°é¢æ¿ç¼–è¾‘äº‹ä»¶ï¼ˆä»é«˜äº®èœå•è§¦å‘ï¼‰
        window.addEventListener('openNotePanelForEdit', function(e) {
            console.log('æ”¶åˆ°æ‰“å¼€ç¬”è®°é¢æ¿ç¼–è¾‘äº‹ä»¶:', e.detail);
            
            if (!book) {
                alert('è¯·å…ˆæ‰“å¼€ä¸€æœ¬ç”µå­ä¹¦');
                return;
            }
            
            // å¦‚æœç¬”è®°é¢æ¿å·²ç»æ‰“å¼€ï¼Œå…ˆå…³é—­
            if (notesVisible) {
                hideNotesPanel();
            }
            
            // æ‰“å¼€ç¬”è®°é¢æ¿å¹¶ä¼ å…¥ç¼–è¾‘æ•°æ®
            showNotesPanel(e.detail);
        });

        // æ¸…é™¤æœç´¢é«˜äº®
        function clearSearchHighlights() {
            if (rendition) {
                try {
                    rendition.annotations.remove('highlight', 'search-highlight');
                } catch (error) {
                    console.log('æ¸…é™¤epub.jsé«˜äº®å¤±è´¥:', error);
                }
                
                // æ¸…é™¤è‡ªå®šä¹‰çš„é«˜äº®span
                try {
                    const views = rendition.views();
                    views.forEach(view => {
                        if (view.contents) {
                            const doc = view.contents.document;
                            const highlights = doc.querySelectorAll('.search-highlight-span');
                            highlights.forEach(el => {
                                const parent = el.parentNode;
                                parent.replaceChild(doc.createTextNode(el.textContent), el);
                                parent.normalize();
                            });
                        }
                    });
                } catch (error) {
                    console.log('æ¸…é™¤è‡ªå®šä¹‰é«˜äº®å¤±è´¥:', error);
                }
            }
        }

        // é«˜äº®æœç´¢ç»“æœ
        function highlightSearchResults(query) {
            if (!rendition || !query.trim()) return;

            try {
                const views = rendition.views();
                views.forEach(view => {
                    if (view.contents) {
                        const doc = view.contents.document;
                        const walker = doc.createTreeWalker(
                            doc.body,
                            NodeFilter.SHOW_TEXT,
                            null,
                            false
                        );

                        const textNodes = [];
                        let node;
                        while (node = walker.nextNode()) {
                            textNodes.push(node);
                        }

                        textNodes.forEach(textNode => {
                            const text = textNode.textContent;
                            const regex = new RegExp(query.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'gi');
                            
                            if (regex.test(text)) {
                                const highlightedText = text.replace(regex, (match) => {
                                    return `<span class="search-highlight-span" style="background-color: #ffeb3b; color: #000; padding: 1px 2px; border-radius: 2px; font-weight: bold;">${match}</span>`;
                                });
                                
                                const tempDiv = doc.createElement('div');
                                tempDiv.innerHTML = highlightedText;
                                
                                const parent = textNode.parentNode;
                                const fragment = doc.createDocumentFragment();
                                
                                while (tempDiv.firstChild) {
                                    fragment.appendChild(tempDiv.firstChild);
                                }
                                
                                parent.replaceChild(fragment, textNode);
                            }
                        });
                    }
                });
            } catch (error) {
                console.log('é«˜äº®æœç´¢ç»“æœå¤±è´¥:', error);
            }
        }

        // ä¸»é¢˜åˆ‡æ¢åŠŸèƒ½
        class ThemeManager {
            constructor() {
                this.currentTheme = localStorage.getItem('tobooks-theme') || 'default';
                this.init();
            }

            init() {
                this.setupEventListeners();
                this.applyTheme(this.currentTheme);
                this.updateActiveTheme();
            }

            setupEventListeners() {
                const themeToggle = document.getElementById('theme-toggle');
                const themeDropdown = document.getElementById('theme-dropdown');
                const themeOptions = document.querySelectorAll('.theme-option');

                // åˆ‡æ¢ä¸‹æ‹‰èœå•æ˜¾ç¤º
                if (themeToggle && themeDropdown) {
                    themeToggle.addEventListener('click', (e) => {
                        e.stopPropagation();
                        const isShow = themeDropdown.classList.toggle('show');
                        // æ·»åŠ /ç§»é™¤ä¸»é¢˜æŒ‰é’®çš„å‡¹é™·æ•ˆæœ
                        if (isShow) {
                            themeToggle.classList.add('active');
                        } else {
                            themeToggle.classList.remove('active');
                        }
                    });
                } else {
                    console.error('ä¸»é¢˜å…ƒç´ æœªæ‰¾åˆ°:', { themeToggle, themeDropdown });
                }

                // ç‚¹å‡»ä¸»é¢˜é€‰é¡¹
                themeOptions.forEach(option => {
                    option.addEventListener('click', (e) => {
                        e.stopPropagation();
                        const theme = option.dataset.theme;
                        this.setTheme(theme);
                        themeDropdown.classList.remove('show');
                    });
                });

                // ç‚¹å‡»å¤–éƒ¨å…³é—­ä¸‹æ‹‰èœå•
                document.addEventListener('click', () => {
                    themeDropdown.classList.remove('show');
                    themeToggle.classList.remove('active');
                });

                // é˜»æ­¢ä¸‹æ‹‰èœå•å†…éƒ¨ç‚¹å‡»äº‹ä»¶å†’æ³¡
                themeDropdown.addEventListener('click', (e) => {
                    e.stopPropagation();
                });
            }

            setTheme(themeName) {
                this.currentTheme = themeName;
                localStorage.setItem('tobooks-theme', themeName);
                this.applyTheme(themeName);
                this.updateActiveTheme();
            }

            applyTheme(themeName) {
                document.documentElement.setAttribute('data-theme', themeName);
                
                // å¦‚æœæœ‰ç”µå­ä¹¦æ­£åœ¨æ˜¾ç¤ºï¼Œä¹Ÿåº”ç”¨ä¸»é¢˜åˆ°é˜…è¯»å™¨å†…å®¹
                if (rendition) {
                    this.applyThemeToReader(themeName);
                }
            }

            applyThemeToReader(themeName) {
                try {
                    const themeStyles = this.getThemeStyles(themeName);
                    rendition.themes.default(themeStyles);
                } catch (error) {
                    console.log('åº”ç”¨ä¸»é¢˜åˆ°é˜…è¯»å™¨å¤±è´¥:', error);
                }
            }

            getThemeStyles(themeName) {
                const themes = {
                    default: {
                        'body': {
                            'background-color': '#f7f7f7',
                            'font-family': '-apple-system, BlinkMacSystemFont, "SF Pro Text", sans-serif'
                        }
                    },
                    ink: {
                        'body': {
                            'background-color': '#f0f0f0',
                            'font-family': '-apple-system, BlinkMacSystemFont, "SF Pro Text", sans-serif'
                        }
                    },
                    blue: {
                        'body': {
                            'background-color': '#f0f4f8',
                            'font-family': '-apple-system, BlinkMacSystemFont, "SF Pro Text", sans-serif'
                        }
                    },
                    purple: {
                        'body': {
                            'background-color': '#f8f4ff',
                            'font-family': '-apple-system, BlinkMacSystemFont, "SF Pro Text", sans-serif'
                        }
                    },
                    green: {
                        'body': {
                            'background-color': '#f0fdf4',
                            'font-family': '-apple-system, BlinkMacSystemFont, "SF Pro Text", sans-serif'
                        }
                    },
                    warm: {
                        'body': {
                            'background-color': '#fef7ed',
                            'font-family': '-apple-system, BlinkMacSystemFont, "SF Pro Text", sans-serif'
                        }
                    },
                    pink: {
                        'body': {
                            'background-color': '#fdf2f8',
                            'font-family': '-apple-system, BlinkMacSystemFont, "SF Pro Text", sans-serif'
                        }
                    },
                };

                return themes[themeName] || themes.default;
            }

            updateActiveTheme() {
                const themeOptions = document.querySelectorAll('.theme-option');
                themeOptions.forEach(option => {
                    option.classList.remove('active');
                    if (option.dataset.theme === this.currentTheme) {
                        option.classList.add('active');
                    }
                });
            }
        }

        // åˆå§‹åŒ–ä¸»é¢˜ç®¡ç†å™¨
        const themeManager = new ThemeManager();
    </script>
</body>
</html>
